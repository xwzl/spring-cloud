# 我们配置了三个数据，其中第一个作为默认数据源也就是我们的master数据源。主要是写操作，那么读操作交给我们的slave1跟slave2
spring:
  datasource:
    #    url: jdbc:mysql://47.105.218.58:3306/qq?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai
    url: jdbc:mysql://172.16.142.128:3306/qq?useUnicode=true&characterEncoding=UTF-8&serverTimezone=GMT%2B8&useSSL=false&allowPublicKeyRetrieval=true
    username: root
    password: root
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    port: 6379
    timeout: 10000ms #连接时间
    host: 172.16.142.128
#    database:
#    password: xuhanlin
#    ssl:
#    cluster:
#      nodes:
#    sentinel:
#      master:
#      nodes:
#  servlet:
#    multipart:
#      max-file-size: 100MB
#      max-request-size: 100MB

# redisson lock
redisson:
  address: redis://172.16.142.128:6379
#  password: xuhanlin
#  master-name: mymas

  ter
#  redisson:
#    sentinel-addresses: 47.105.218.58:6739


mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
  type-aliases-package: com.spring.demo.model
  mapper-locations: classpath:com/spring/demo/mapper/*.xml

logging:
  level:
    com.spring.demo.mapper: debug
    io.swagger.models.parameters.AbstractSerializableParameter: error
#  config: classpath:logback-springs.xml
#  logstash:
#    host: 192.168.20.130:5000
# httpClient 连接池配置
http:
  maxTotal: 100
  #并发数
  defaultMaxPerRoute: 20
  #创建连接的最长时间
  connectTimeout: 1000
  #从连接池中获取到连接的最长时间
  connectionRequestTimeout: 500
  #数据传输的最长时间
  socketTimeout: 10000
  #提交请求前测试连接是否可用
  staleConnectionCheckEnabled: true

# 异步线程池配置文件
sync:
  pool:
    core-size: 10
    await-time: 60
    alive-time: 200
    queue-capacity: 25
    max-size: 20

# 百度图片识别
baidu:
  picture:
    client:
      appId: 17742567
      appKey: eXsrrHSvWhGGbG6SCpKr5vvB
      secretKey: PoNAGHge3G7Cc5Er2wVz3Uk3rIAIhBte
