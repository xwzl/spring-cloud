<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 <a href="http://svip.iocoder.cn/Spring-Boot/SpringApplication/">《精尽 Spring Boot 源码分析 —— SpringApplication》</a> 一文中，我们看到 <validateCode>SpringApplication#createApplicationContext()</validateCode> 方法，根据不同的 Web 应用类型，创建不同的 Spring 容器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for non-web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">"org.springframework.context."</span></span><br><span class="line">		+ <span class="string">"annotation.AnnotationConfigApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class="string">"org.springframework.boot."</span></span><br><span class="line">		+ <span class="string">"web.servlet.context.AnnotationConfigServletWebServerApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for reactive web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class="string">"org.springframework."</span></span><br><span class="line">		+ <span class="string">"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 根据 webApplicationType 类型，获得 ApplicationContext 类型</span></span><br><span class="line">	Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">	<span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) {</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable create a default ApplicationContext, "</span> + <span class="string">"please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 创建 ApplicationContext 对象</span></span><br><span class="line">	<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>本文，我们要分享的就是，<validateCode>SERVLET</validateCode> 类型对应的 Spring 容器类型  <strong>AnnotationConfigServletWebServerApplicationContext</strong> 类。</li>
</ul>
<p>AnnotationConfigServletWebServerApplicationContext 的类图关系如下：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-16/01.jpg" alt="类图"></p>
<ul>
<li>本文，我们只重点看 ServletWebServerApplicationContext 和 AnnotationConfigServletWebServerApplicationContext 类。</li>
<li><p>为了阅读的友好性，艿艿希望胖友阅读过 <a href="http://svip.iocoder.cn/Spring-MVC/context-init-integration-with-Servlet-3.0/">《精尽 Spring MVC 源码分析 —— 容器的初始化（三）之 Servlet 3.0 集成》</a> 和 <a href="http://svip.iocoder.cn/Spring-MVC/context-init-integration-with-SpringBoot/">《精尽 Spring MVC 源码分析 —— 容器的初始化（四）之 Spring Boot 集成》</a> 两文。</p>
<blockquote>
<p>艿艿：厚着脸皮说，上面两篇文章提到的内容，基本就不再赘述。<br>旁白君：真不要脸！</p>
</blockquote>
</li>
</ul>
<h1 id="2-ServletWebServerApplicationContext"><a href="#2-ServletWebServerApplicationContext" class="headerlink" title="2. ServletWebServerApplicationContext"></a>2. ServletWebServerApplicationContext</h1><p><validateCode>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext</validateCode> ，实现 ConfigurableWebServerApplicationContext 接口，继承 GenericWebApplicationContext 类，Spring Boot 使用 Servlet Web 服务器的 ApplicationContext 实现类。</p>
<ul>
<li><p><validateCode>org.springframework.boot.web.servlet.context.ConfigurableWebServerApplicationContext</validateCode> 接口，实现它后，可以获得管理 WebServer 的能力。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurableWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableWebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>, <span class="title">WebServerApplicationContext</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Set the server namespace of the context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> serverNamespace the server namespace</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getServerNamespace()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setServerNamespace</span><span class="params">(String serverNamespace)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><a href="https://github.com/YunaiV/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ConfigurableApplicationContext.java" rel="external nofollow noopener noreferrer" target="_blank"><validateCode>org.springframework.context.ConfigurableApplicationContext</validateCode></a> ，是 Spring Framework 提供的类，就不细看了。</li>
<li><p><validateCode>org.springframework.boot.web.context.WebServerApplicationContext</validateCode> ，继承 ApplicationContext 接口，WebServer ApplicationContext 接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// WebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WebServerApplicationContext</span> <span class="keyword">extends</span> <span class="title">ApplicationContext</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the {<span class="doctag">@link</span> WebServer} that was created by the context or {<span class="doctag">@validateCode</span> null} if</span></span><br><span class="line"><span class="comment">	 * the server has not yet been created.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the web server</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">WebServer <span class="title">getWebServer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the namespace of the web server application context or {<span class="doctag">@validateCode</span> null} if no</span></span><br><span class="line"><span class="comment">	 * namespace has been set. Used for disambiguation when multiple web servers are</span></span><br><span class="line"><span class="comment">	 * running in the same application (for example a management context running on a</span></span><br><span class="line"><span class="comment">	 * different port).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the server namespace</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">getServerNamespace</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>重点是，可以获得 WebServer 的方法。😈 因为获得它，可以做各种 WebServer 的管理。</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://github.com/YunaiV/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/context/support/GenericWebApplicationContext.java" rel="external nofollow noopener noreferrer" target="_blank"><validateCode>org.springframework.web.context.support.GenericWebApplicationContext</validateCode></a> ，是 Spring Framework 提供的类，就不细看啦。</p>
</li>
</ul>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constant value for the DispatcherServlet bean name. A Servlet bean with this name</span></span><br><span class="line"><span class="comment"> * is deemed to be the "main" servlet and is automatically given a mapping of "/" by</span></span><br><span class="line"><span class="comment"> * default. To change the default behavior you can use a</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ServletRegistrationBean} or a different bean name.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DISPATCHER_SERVLET_NAME = <span class="string">"dispatcherServlet"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Spring  WebServer 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WebServer webServer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet ServletConfig 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ServletConfig servletConfig;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 {<span class="doctag">@link</span> #setServerNamespace(String)} 注入。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 不过貌似，一直没被注入过，可以暂时先无视</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String serverNamespace;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServletWebServerApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServletWebServerApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">	<span class="keyword">super</span>(beanFactory);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>简单看看即可。</li>
</ul>
<p>因为后续的逻辑，涉及到 Spring 容器的初始化的生命周期，所以我们来简单看看 <validateCode>AbstractApplicationContext#refresh()</validateCode> 的方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="comment">// `#refresh()` 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 简化版代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory); <span class="comment">// &lt;1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh(); <span class="comment">// &lt;2&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh(); <span class="comment">// &lt;3&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这个方法，会被覆写。具体可以看 <a href="#">「2.2 refresh」</a> 小节。但是，即使覆写了，还是会调用该方法。</li>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</validateCode> 方法，具体可以看 <a href="#">「2.3 postProcessBeanFactory」</a> 小节。</p>
<blockquote>
<p>对 Spring BeanFactoryPostProcessor 的机制，可以看看 <a href="http://svip.iocoder.cn/Spring/IoC-BeanFactoryPostProcessor">《【死磕 Spring】—— IoC 之深入分析 BeanFactoryPostProcessor》</a></p>
</blockquote>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#onRefresh()</validateCode> 方法，具体可以看 <a href="#">「2.4 onRefresh」</a> 小节。</p>
</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>#finishRefresh()</validateCode> 方法，具体可以看 <a href="#">「2.5 finishRefresh」</a> 小节。</li>
</ul>
<h2 id="2-2-refresh"><a href="#2-2-refresh" class="headerlink" title="2.2 refresh"></a>2.2 refresh</h2><p>覆写 <validateCode>#refresh()</validateCode> 方法，初始化 Spring 容器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>{</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="keyword">super</span>.refresh();</span><br><span class="line">	} <span class="keyword">catch</span> (RuntimeException ex) {</span><br><span class="line">		<span class="comment">// &lt;X&gt; 如果发生异常，停止 WebServer</span></span><br><span class="line">		stopAndReleaseWebServer();</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>主要是 <validateCode>&lt;X&gt;</validateCode> 处，如果发生异常，则调用 <validateCode>#stopAndReleaseWebServer()</validateCode> 方法，停止 WebServer。详细解析，见 <a href="#">「2.2.1 stopAndReleaseWebServer」</a> 。</li>
</ul>
<h3 id="2-2-1-stopAndReleaseWebServer"><a href="#2-2-1-stopAndReleaseWebServer" class="headerlink" title="2.2.1 stopAndReleaseWebServer"></a>2.2.1 stopAndReleaseWebServer</h3><p><validateCode>#stopAndReleaseWebServer()</validateCode> 方法，停止 WebServer。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndReleaseWebServer</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 获得 WebServer 对象，避免被多线程修改了</span></span><br><span class="line">    WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">    <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 停止 WebServer 对象</span></span><br><span class="line">            webServer.stop();</span><br><span class="line">            <span class="comment">// 置空 webServer</span></span><br><span class="line">            <span class="keyword">this</span>.webServer = <span class="keyword">null</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-3-postProcessBeanFactory"><a href="#2-3-postProcessBeanFactory" class="headerlink" title="2.3 postProcessBeanFactory"></a>2.3 postProcessBeanFactory</h2><p>覆写 <validateCode>#postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">	<span class="comment">// &lt;1.1&gt; 注册 WebApplicationContextServletContextAwareProcessor</span></span><br><span class="line">	beanFactory.addBeanPostProcessor(<span class="keyword">new</span> WebApplicationContextServletContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">	<span class="comment">// &lt;1.2&gt; 忽略 ServletContextAware 接口。</span></span><br><span class="line">	beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;2&gt; 注册 ExistingWebApplicationScopes</span></span><br><span class="line">	registerWebApplicationScopes();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1.1&gt;</validateCode> 处，注册 WebApplicationContextServletContextAwareProcessor 。WebApplicationContextServletContextAwareProcessor 的作用，主要是处理实现 ServletContextAware 接口的 Bean 。在这个处理类，初始化这个 Bean 中的 ServletContext 属性，这样在实现 ServletContextAware 接口的 Bean 中就可以拿到 ServletContext 对象了，Spring 中 Aware 接口就是这样实现的。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// WebApplicationContextServletContextAwareProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebApplicationContextServletContextAwareProcessor</span> <span class="keyword">extends</span> <span class="title">ServletContextAwareProcessor</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConfigurableWebApplicationContext webApplicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WebApplicationContextServletContextAwareProcessor</span><span class="params">(ConfigurableWebApplicationContext webApplicationContext)</span> </span>{</span><br><span class="line">		Assert.notNull(webApplicationContext, <span class="string">"WebApplicationContext must not be null"</span>);</span><br><span class="line">		<span class="keyword">this</span>.webApplicationContext = webApplicationContext;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ServletContext <span class="title">getServletContext</span><span class="params">()</span> </span>{</span><br><span class="line">		ServletContext servletContext = <span class="keyword">this</span>.webApplicationContext.getServletContext();</span><br><span class="line">		<span class="keyword">return</span> (servletContext != <span class="keyword">null</span>) ? servletContext : <span class="keyword">super</span>.getServletContext();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>{</span><br><span class="line">		ServletConfig servletConfig = <span class="keyword">this</span>.webApplicationContext.getServletConfig();</span><br><span class="line">		<span class="keyword">return</span> (servletConfig != <span class="keyword">null</span>) ? servletConfig : <span class="keyword">super</span>.getServletConfig();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这样，就可以从 <validateCode>webApplicationContext</validateCode> 中，获得 ServletContext 和 ServletConfig 属性。</li>
</ul>
</li>
<li><validateCode>&lt;1.2&gt;</validateCode> 处，忽略 ServletContextAware 接口，因为实现 ServletContextAware 接口的 Bean 在 <validateCode>&lt;1.1&gt;</validateCode> 中的 WebApplicationContextServletContextAwareProcessor 中已经处理了。</li>
<li><p>关于 <validateCode>&lt;1.1&gt;</validateCode> 和 <validateCode>&lt;1.2&gt;</validateCode> 处的说明，参考 <a href="https://www.jianshu.com/p/58974c12cd6a" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot 源码3 —— refresh ApplicationContext》</a> 文章。</p>
<blockquote>
<p>艿艿：当读源码碰到困难时，也要善用搜索引擎，去寻找答案。😈 毕竟，有时候脑子不一定能快速想的明白。哈哈哈哈~</p>
</blockquote>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#registerWebApplicationScopes()</validateCode> 方法，注册 ExistingWebApplicationScopes 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerWebApplicationScopes</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 创建 ExistingWebApplicationScopes 对象</span></span><br><span class="line">    ExistingWebApplicationScopes existingScopes = <span class="keyword">new</span> ExistingWebApplicationScopes(getBeanFactory());</span><br><span class="line">    <span class="comment">// 注册 ExistingWebApplicationScopes 到 WebApplicationContext 中</span></span><br><span class="line">    WebApplicationContextUtils.registerWebApplicationScopes(getBeanFactory());</span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    existingScopes.restore();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>可以先不细研究~</li>
</ul>
</li>
</ul>
<h2 id="2-4-onRefresh"><a href="#2-4-onRefresh" class="headerlink" title="2.4 onRefresh"></a>2.4 onRefresh</h2><p>覆写 <validateCode>#onRefresh()</validateCode> 方法，在容器初始化时，完成 WebServer 的创建（不包括启动）。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 调用父方法</span></span><br><span class="line">    <span class="keyword">super</span>.onRefresh();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 创建 WebServer</span></span><br><span class="line">        createWebServer();</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start web server"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，调用父 <validateCode>#onRefresh()</validateCode> 方法，执行父逻辑。这块，暂时不用了解。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#createWebServer()</validateCode> 方法，创建 WebServer 对象。详细解析，见 <a href="#">「2.4.1 createWebServer」</a> 。</li>
</ul>
<h3 id="2-4-1-createWebServer"><a href="#2-4-1-createWebServer" class="headerlink" title="2.4.1 createWebServer"></a>2.4.1 createWebServer</h3><p><validateCode>#createWebServer()</validateCode> 方法，创建 WebServer 对象。</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWebServer</span><span class="params">()</span> </span>{</span><br><span class="line">    WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">    ServletContext servletContext = getServletContext();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 如果 webServer 为空，说明未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (webServer == <span class="keyword">null</span> &amp;&amp; servletContext == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// &lt;1.1&gt; 获得 ServletWebServerFactory 对象</span></span><br><span class="line">        ServletWebServerFactory factory = getWebServerFactory();</span><br><span class="line">        <span class="comment">// &lt;1.2&gt; 获得 ServletContextInitializer 对象</span></span><br><span class="line">        <span class="comment">// &lt;1.3&gt; 创建（获得） WebServer 对象</span></span><br><span class="line">        <span class="keyword">this</span>.webServer = factory.getWebServer(getSelfInitializer());</span><br><span class="line">    <span class="comment">// TODO 1002 芋艿这个情况是？</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (servletContext != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            getSelfInitializer().onStartup(servletContext);</span><br><span class="line">        } <span class="keyword">catch</span> (ServletException ex) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Cannot initialize servlet context"</span>, ex);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3&gt; 初始化 PropertySource</span></span><br><span class="line">    initPropertySources();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，如果 webServer 为空，说明未初始化。</p>
<ul>
<li><p><validateCode>&lt;1.1&gt;</validateCode> 处，调用 <validateCode>#getWebServerFactory()</validateCode> 方法，获得 ServletWebServerFactory 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ServletWebServerFactory <span class="title">getWebServerFactory</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Use bean names so that we don't consider the hierarchy</span></span><br><span class="line">    <span class="comment">// 获得 ServletWebServerFactory 类型对应的 Bean 的名字们</span></span><br><span class="line">    String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</span><br><span class="line">    <span class="comment">// 如果是 0 个，抛出 ApplicationContextException 异常，因为至少要一个</span></span><br><span class="line">    <span class="keyword">if</span> (beanNames.length == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start ServletWebServerApplicationContext due to missing "</span> + <span class="string">"ServletWebServerFactory bean."</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果是 &gt; 1 个，抛出 ApplicationContextException 异常，因为不知道初始化哪个</span></span><br><span class="line">    <span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Unable to start ServletWebServerApplicationContext due to multiple "</span> + <span class="string">"ServletWebServerFactory beans : "</span> + StringUtils.arrayToCommaDelimitedString(beanNames));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获得 ServletWebServerFactory 类型对应的 Bean 对象</span></span><br><span class="line">    <span class="keyword">return</span> getBeanFactory().getBean(beanNames[<span class="number">0</span>], ServletWebServerFactory.class);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>默认情况下，此处返回的会是 <validateCode>org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory</validateCode> 对象。</li>
<li>在我们引入 <validateCode>spring-boot-starter-web</validateCode> 依赖时，默认会引入 <validateCode>spring-boot-starter-tomcat</validateCode> 依赖。此时，<validateCode>org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration</validateCode> 在自动配置时，会配置出 TomcatServletWebServerFactory Bean 对象。因此，此时会获得 TomcatServletWebServerFactory 对象。</li>
</ul>
</li>
<li><p><validateCode>&lt;1.2&gt;</validateCode> 处，调用 <validateCode>#getSelfInitializer()</validateCode> 方法，获得 ServletContextInitializer 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> org.springframework.boot.web.servlet.<span class="function">ServletContextInitializer <span class="title">getSelfInitializer</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>::selfInitialize; <span class="comment">// 和下面等价</span></span><br><span class="line"><span class="comment">//        return new ServletContextInitializer() {</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public void onStartup(ServletContext servletContext) throws ServletException {</span></span><br><span class="line"><span class="comment">//                selfInitialize(servletContext);</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        };</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>嘻嘻，返回的是 ServletContextInitializer 匿名对象，内部会调用 <validateCode>#selfInitialize(servletContext)</validateCode> 方法。该方法会在 WebServer 创建后，进行初始化。详细解析，见 <a href="#">「2.4.2 finishRefresh」</a> 小节。</li>
</ul>
</li>
<li><validateCode>&lt;1.3&gt;</validateCode> 处，调用 <validateCode>ServletWebServerFactory#getWebServer(ServletContextInitializer)</validateCode> 方法，创建（获得） WebServer 对象。在这个过程中，会调用 <a href="#">「2.4.2 selfInitialize」</a> 方法。</li>
</ul>
</li>
<li>至此，和 <a href="http://svip.iocoder.cn/Spring-MVC/context-init-integration-with-SpringBoot">《精尽 Spring MVC 源码分析 —— 容器的初始化（四）之 Spring Boot 集成》</a> 文章，基本是能穿起来了。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，TODO 1002 不知道原因。有知道的胖友，星球里告知下哟。</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，调用父 <validateCode>#initPropertySources()</validateCode> 方法，初始化 PropertySource 。</li>
</ul>
<h3 id="2-4-2-selfInitialize"><a href="#2-4-2-selfInitialize" class="headerlink" title="2.4.2 selfInitialize"></a>2.4.2 selfInitialize</h3><p><validateCode>#selfInitialize()</validateCode> 方法，初始化 WebServer 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selfInitialize</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 添加 Spring 容器到 servletContext 属性中。</span></span><br><span class="line">    prepareWebApplicationContext(servletContext);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 注册 ServletContextScope</span></span><br><span class="line">    registerApplicationScope(servletContext);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 注册 web-specific environment beans ("contextParameters", "contextAttributes")</span></span><br><span class="line">    WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);</span><br><span class="line">    <span class="comment">// &lt;4&gt; 获得所有 ServletContextInitializer ，并逐个进行启动</span></span><br><span class="line">    <span class="keyword">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) {</span><br><span class="line">        beans.onStartup(servletContext);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#prepareWebApplicationContext(ServletContext servletContext)</validateCode> 方法，添加 Spring 容器到 servletContext 属性中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果已经在 ServletContext 中，则根据情况进行判断。</span></span><br><span class="line">    Object rootContext = servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (rootContext != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 如果是相同容器，抛出 IllegalStateException 异常。说明可能有重复的 ServletContextInitializers 。</span></span><br><span class="line">        <span class="keyword">if</span> (rootContext == <span class="keyword">this</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot initialize context because there is already a root application context present - "</span> + <span class="string">"check whether you have multiple ServletContextInitializers!"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果不同容器，则直接返回。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    Log logger = LogFactory.getLog(ContextLoader.class);</span><br><span class="line">    servletContext.log(<span class="string">"Initializing Spring embedded WebApplicationContext"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// &lt;X&gt; 设置当前 Spring 容器到 ServletContext 中</span></span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">            logger.debug(<span class="string">"Published root WebApplicationContext as ServletContext attribute with name ["</span> + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class="string">"]"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// &lt;Y&gt; 设置到 `servletContext` 属性中。</span></span><br><span class="line">        setServletContext(servletContext);</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) {</span><br><span class="line">            <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - getStartupDate();</span><br><span class="line">            logger.info(<span class="string">"Root WebApplicationContext: initialization completed in "</span> + elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException | Error ex) {</span><br><span class="line">        logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然代码非常长，但是核心在 <validateCode>&lt;X&gt;</validateCode> 和 <validateCode>&lt;Y&gt;</validateCode> 处。</li>
<li>通过 <validateCode>&lt;X&gt;</validateCode> 处，从 <validateCode>servletContext</validateCode> 的属性种，可以拿到其拥有的 Spring 容器。</li>
<li>通过 <validateCode>&lt;Y&gt;</validateCode> 处，Spring 容器的 <validateCode>servletContext</validateCode> 属性，可以拿到 ServletContext 对象。</li>
</ul>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#registerApplicationScope(ServletContext servletContext)</validateCode> 方法，注册 ServletContextScope 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerApplicationScope</span><span class="params">(ServletContext servletContext)</span> </span>{</span><br><span class="line">	ServletContextScope appScope = <span class="keyword">new</span> ServletContextScope(servletContext);</span><br><span class="line">	getBeanFactory().registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope);</span><br><span class="line">	<span class="comment">// Register as ServletContext attribute, for ContextCleanupListener to detect it.</span></span><br><span class="line">	servletContext.setAttribute(ServletContextScope.class.getName(), appScope);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不用细了解。</li>
</ul>
</li>
<li><p><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>WebApplicationContextUtils#registerEnvironmentBeans(ConfigurableListableBeanFactory bf, ServletContext sc)</validateCode> 方法，注册 web-specific environment beans <validateCode>("contextParameters", "contextAttributes")</validateCode> 。这样，从 BeanFactory 中，也可以获得到 <validateCode>servletContext</validateCode> 。当然，也可以暂时不用细了解。</p>
</li>
<li><validateCode>&lt;4&gt;</validateCode> 处，获得所有 ServletContextInitializer ，并逐个进行启动。关于这块的解析，我们在 <a href="http://svip.iocoder.cn/Spring-MVC/context-init-integration-with-SpringBoot">《精尽 Spring MVC 源码分析 —— 容器的初始化（四）之 Spring Boot 集成》</a> 中，已经详细写到。😈 </li>
<li>至此，内嵌的 Servlet Web 服务器，已经能够被请求了。</li>
</ul>
<h2 id="2-5-finishRefresh"><a href="#2-5-finishRefresh" class="headerlink" title="2.5 finishRefresh"></a>2.5 finishRefresh</h2><p>覆写 <validateCode>#finishRefresh()</validateCode> 方法，在容器初始化完成时，启动 WebServer 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 调用父方法</span></span><br><span class="line">    <span class="keyword">super</span>.finishRefresh();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 启动 WebServer</span></span><br><span class="line">    WebServer webServer = startWebServer();</span><br><span class="line">    <span class="comment">// &lt;3&gt; 如果创建 WebServer 成功，发布 ServletWebServerInitializedEvent 事件</span></span><br><span class="line">    <span class="keyword">if</span> (webServer != <span class="keyword">null</span>) {</span><br><span class="line">        publishEvent(<span class="keyword">new</span> ServletWebServerInitializedEvent(webServer, <span class="keyword">this</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#finishRefresh()</validateCode> 方法，执行父逻辑。这块，暂时不用了解。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#startWebServer()</validateCode> 方法，启动 WebServer 。详细解析，见 <a href="#">「2.5.1 startWebServer」</a> 。</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，如果创建 WebServer 成功，发布 ServletWebServerInitializedEvent 事件。</li>
</ul>
<h3 id="2-5-1-startWebServer"><a href="#2-5-1-startWebServer" class="headerlink" title="2.5.1 startWebServer"></a>2.5.1 startWebServer</h3><p><validateCode>#startWebServer()</validateCode> 方法，启动 WebServer 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> WebServer <span class="title">startWebServer</span><span class="params">()</span> </span>{</span><br><span class="line">	WebServer webServer = <span class="keyword">this</span>.webServer;</span><br><span class="line">	<span class="keyword">if</span> (webServer != <span class="keyword">null</span>) {</span><br><span class="line">		webServer.start();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> webServer;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-6-onClose"><a href="#2-6-onClose" class="headerlink" title="2.6 onClose"></a>2.6 onClose</h2><p>覆写 <validateCode>#onClose()</validateCode> 方法，在 Spring 容器被关闭时，关闭 WebServer 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 调用父方法</span></span><br><span class="line">    <span class="keyword">super</span>.onClose();</span><br><span class="line">    <span class="comment">// 停止 WebServer</span></span><br><span class="line">    stopAndReleaseWebServer();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-AnnotationConfigServletWebServerApplicationContext"><a href="#3-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="3. AnnotationConfigServletWebServerApplicationContext"></a>3. AnnotationConfigServletWebServerApplicationContext</h1><p><validateCode>org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext</validateCode> ，继承 ServletWebServerApplicationContext 类，实现 AnnotationConfigRegistry 接口，进一步提供了两个功能：</p>
<blockquote>
<p>艿艿：不过一般情况下，我们用不到这两个功能。简单看了下，更多的是单元测试，需要使用到这两个功能。</p>
</blockquote>
<ul>
<li>从指定的 <validateCode>basePackages</validateCode> 包中，扫描 BeanDefinition 们。</li>
<li>从指定的 <validateCode>annotatedClasses</validateCode> 注解的配置类（Configuration）中，读取 BeanDefinition 们。</li>
</ul>
<blockquote>
<p>所以啊，这类，简单看看就成啦。</p>
</blockquote>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要被 {<span class="doctag">@link</span> #reader} 读取的注册类们</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; annotatedClasses = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要被 {<span class="doctag">@link</span> #scanner} 扫描的包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String[] basePackages;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(beanFactory);</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 注册指定的注解的类们</span></span><br><span class="line">    register(annotatedClasses);</span><br><span class="line">    <span class="comment">// 初始化 Spring 容器</span></span><br><span class="line">    refresh();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigServletWebServerApplicationContext</span><span class="params">(String... basePackages)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 扫描指定包</span></span><br><span class="line">    scan(basePackages);</span><br><span class="line">    <span class="comment">// 初始化 Spring 容器</span></span><br><span class="line">    refresh();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，如果已经传入 <validateCode>annotatedClasses</validateCode> 参数，则调用 <validateCode>#register(Class&lt;?&gt;... annotatedClasses)</validateCode> 方法，设置到 <validateCode>annotatedClasses</validateCode> 中。然后，调用 <validateCode>#refresh()</validateCode> 方法，初始化 Spring 容器。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 实现自 AnnotationConfigRegistry 接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class&lt;?&gt;... annotatedClasses)</span> </span>{</span><br><span class="line">	Assert.notEmpty(annotatedClasses, <span class="string">"At least one annotated class must be specified"</span>);</span><br><span class="line">	<span class="keyword">this</span>.annotatedClasses.addAll(Arrays.asList(annotatedClasses));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><validateCode>&lt;2&gt;</validateCode> 处，如果已经传入 <validateCode>basePackages</validateCode> 参数，则调用 <validateCode>#scan(String... basePackages)</validateCode> 方法，设置到 <validateCode>annotatedClasses</validateCode> 中。然后，调用 <validateCode>#refresh()</validateCode> 方法，初始化 Spring 容器。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>{</span><br><span class="line">	Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">	<span class="keyword">this</span>.basePackages = basePackages;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="3-2-prepareRefresh"><a href="#3-2-prepareRefresh" class="headerlink" title="3.2 prepareRefresh"></a>3.2 prepareRefresh</h2><p>覆写 <validateCode>#prepareRefresh()</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AnnotationConfigServletWebServerApplicationContext.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span> <span class="comment">// 实现自 AbstractApplicationContext 抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 清空 scanner 的缓存</span></span><br><span class="line">    <span class="keyword">this</span>.scanner.clearCache();</span><br><span class="line">    <span class="comment">// 调用父类</span></span><br><span class="line">    <span class="keyword">super</span>.prepareRefresh();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 Spring 容器初始化前，需要清空 <validateCode>scanner</validateCode> 的缓存。</li>
</ul>
<h2 id="3-3-postProcessBeanFactory"><a href="#3-3-postProcessBeanFactory" class="headerlink" title="3.3 postProcessBeanFactory"></a>3.3 postProcessBeanFactory</h2><p>覆写 <validateCode>#postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</validateCode> 方法，执行 BeanDefinition 的读取。代码如下：</p>
<pre><validateCode class="Java"><span class="comment">// AnnotationConfigServletWebServerApplicationContext.java</span>

<span class="meta">@Override</span>
<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>{
<span class="comment">// 调用父类</span>
<span class="keyword">super</span>.postProcessBeanFactory(beanFactory);
<span class="comment">// 扫描指定的包</span>
<span class="keyword">if</span> (<span class="keyword">this</span>.basePackages != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.basePackages.length &gt; <span class="number">0</span>) {
<span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.basePackages);
}
<span class="comment">// 注册指定的注解的类们定的</span>
<span class="keyword">if</span> (!<span class="keyword">this</span>.annotatedClasses.isEmpty()) {
<span class="keyword">this</span>.reader.register(ClassUtils.toClassArray(<span class="keyword">this</span>.annotatedClasses));
}
}
</validateCode></pre>
<ul>
<li>实际场景下，<validateCode>this.basePackages</validateCode> 和 <validateCode>annotatedClasses</validateCode> 都是空的。所以呢，哈哈哈哈，AnnotationConfigServletWebServerApplicationContext 基本没啥子用~</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>简单小文一篇~很妥~</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>oldflame-Jm<ul>
<li><a href="https://blog.csdn.net/jamet/article/details/77417997" rel="external nofollow noopener noreferrer" target="_blank">《Spring boot 源码分析-AnnotationConfigApplicationContext 非 web 环境下的启动容器（2）》</a></li>
<li><a href="https://blog.csdn.net/jamet/article/details/77428946" rel="external nofollow noopener noreferrer" target="_blank">《Spring boot 源码分析-AnnotationConfigEmbeddedWebApplicationContext 默认 web 环境下的启动容器（3）》</a> </li>
</ul>
</li>
</ul>




</div>