<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MVCApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(MVCApplication.class, args); <span class="comment">// &lt;2&gt;</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，使用 <validateCode>@SpringBootApplication</validateCode> 注解，标明是 Spring Boot 应用。通过它，可以开启自动配置的功能。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>SpringApplication#run(Class&lt;?&gt;... primarySources)</validateCode> 方法，启动 Spring Boot 应用。</li>
</ul>
<p>上述的代码，是我们使用 Spring Boot 时，最最最常用的代码。而本文，我们先来分析 Spring Boot 应用的<strong>启动过程</strong>。</p>
<blockquote>
<p>关于 <validateCode>@SpringApplication</validateCode> 注解，我们会后面单独开文章，详细解析。</p>
</blockquote>
<h1 id="2-SpringApplication"><a href="#2-SpringApplication" class="headerlink" title="2. SpringApplication"></a>2. SpringApplication</h1><p><validateCode>org.springframework.boot.SpringApplication</validateCode> ，Spring 应用启动器。正如其代码上所添加的注释，它来提供启动 Spring 应用的功能。</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line">Class that can be used to bootstrap and launch a Spring application from a Java main method.</span><br></pre></td></tr></tbody></table></figure>
<p>大多数情况下，我们都是使用它提供的<strong>静态</strong>方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">	SpringApplication.run(<span class="keyword">new</span> Class&lt;?&gt;[<span class="number">0</span>], args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> run(<span class="keyword">new</span> Class&lt;?&gt;[] { primarySource }, args);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> </span>{</span><br><span class="line">	<span class="comment">// 创建 SpringApplication 对象，并执行运行。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplication(primarySources).run(args);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>前两个静态方法，最终调用的是第 3 个静态方法。而第 3 个静态方法，实现的逻辑就是：<ul>
<li>首先，创建一个 SpringApplication 对象。详细的解析，见 <a href="#">「2.1 构造方法」</a> 。</li>
<li>然后，调用 <validateCode>SpringApplication#run(Class&lt;?&gt; primarySource, String... args)</validateCode> 方法，运行 Spring 应用。详细解析，见 <a href="#">「2.2 run」</a> 。</li>
</ul>
</li>
</ul>
<h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1 构造方法"></a>2.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 资源加载器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要的 Java Config 类的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; primarySources;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Web 应用类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> WebApplicationType webApplicationType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ApplicationContextInitializer 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ApplicationListener 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, primarySources);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 初始化 initializers 属性</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// 初始化 listeners 属性</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>SpringApplication 的变量比较多，我们先只看构造方法提到的几个。</li>
<li><validateCode>resourceLoader</validateCode> 属性，资源加载器。可以暂时不理解，感兴趣的胖友，可以看看 <a href="http://svip.iocoder.cn/Spring/IoC-load-Resource/?vip">《【死磕 Spring】—— IoC 之 Spring 统一资源加载策略》</a> 文章。</li>
<li><validateCode>primarySources</validateCode> 属性，主要的 Java Config 类的数组。在文初提供的示例，就是 MVCApplication 类。</li>
<li><validateCode>webApplicationType</validateCode> 属性，调用 <validateCode>WebApplicationType#deduceFromClasspath()</validateCode> 方法，通过 classpath ，判断 Web 应用类型。<ul>
<li>具体的原理是，是否存在指定的类，艿艿已经在 <a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/WebApplicationType.java" rel="external nofollow noopener noreferrer" target="_blank">WebApplicationType</a> 上的方法添加了注释，直接瞅一眼就明白了。</li>
<li>这个属性，在下面的 <validateCode>#createApplicationContext()</validateCode> 方法，将根据它的值（类型），创建不同类型的 ApplicationContext 对象，即 Spring 容器的类型不同。</li>
</ul>
</li>
<li><validateCode>initializers</validateCode> 属性，ApplicationContextInitializer 数组。<ul>
<li>通过 <validateCode>#getSpringFactoriesInstances(Class&lt;T&gt; type)</validateCode> 方法，进行获得 ApplicationContextInitializer 类型的对象数组，详细的解析，见 <a href="#">「2.1.1 getSpringFactoriesInstances」</a> 方法。</li>
<li>假设只在 Spring MVC 的环境下，<validateCode>initializers</validateCode> 属性的结果如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-07/01.jpg" alt="`initializers` 属性"></li>
</ul>
</li>
<li><validateCode>listeners</validateCode> 属性，ApplicationListener 数组。<ul>
<li>也是通过 <validateCode>#getSpringFactoriesInstances(Class&lt;T&gt; type)</validateCode> 方法，进行获得 ApplicationListener 类型的对象数组。</li>
<li>假设只在 Spring MVC 的环境下，<validateCode>listeners</validateCode> 属性的结果如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-07/02.jpg" alt="`listeners` 属性"></li>
</ul>
</li>
<li><p><validateCode>mainApplicationClass</validateCode> 属性，调用 <validateCode>#deduceMainApplicationClass()</validateCode> 方法，获得是调用了哪个 <validateCode>#main(String[] args)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() {</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="comment">// 获得当前 StackTraceElement 数组</span></span><br><span class="line">		StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">		<span class="comment">// 判断哪个执行了 main 方法</span></span><br><span class="line">		<span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) {</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) {</span><br><span class="line">				<span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	} <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">		<span class="comment">// Swallow and continue</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在文初的例子中，就是 MVCApplication 类。</li>
<li>这个 <validateCode>mainApplicationClass</validateCode> 属性，没有什么逻辑上的用途，主要就是用来打印下日志，说明是通过这个类启动 Spring 应用的。</li>
</ul>
</li>
</ul>
<h3 id="2-1-1-getSpringFactoriesInstances"><a href="#2-1-1-getSpringFactoriesInstances" class="headerlink" title="2.1.1 getSpringFactoriesInstances"></a>2.1.1 getSpringFactoriesInstances</h3><p><validateCode>#getSpringFactoriesInstances(Class&lt;T&gt; type)</validateCode> 方法，获得指定类类对应的对象们。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] {});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>{</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 加载指定类型对应的，在 `META-INF/spring.factories` 里的类名的数组</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</span><br><span class="line">            SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// &lt;2&gt; 创建对象们</span></span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,</span><br><span class="line">            classLoader, args, names);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 排序对象们</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>SpringFactoriesLoader#loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</validateCode> 方法，加载指定类型对应的，在 <validateCode>META-INF/spring.factories</validateCode> 里的类名的数组。<ul>
<li>在 <a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories" rel="external nofollow noopener noreferrer" target="_blank"><validateCode>META-INF/spring.factories</validateCode></a> 文件中，会以 KEY-VALUE 的格式，配置每个类对应的实现类们。</li>
<li>关于 SpringFactoriesLoader 的该方法，我们就不去细看了。😈 很多时候，我们看源码的时候，不需要陷入到每个方法的细节中。非关键的方法，猜测到具体的用途后，跳过也是没问题的。</li>
</ul>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names)</validateCode> 方法，创建对象们。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建对象的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type 父类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterTypes 构造方法的参数类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader 类加载器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> names 类名的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 对象的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">createSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">		Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">		Set&lt;String&gt; names)</span> </span>{</span><br><span class="line">	List&lt;T&gt; instances = <span class="keyword">new</span> ArrayList&lt;&gt;(names.size()); <span class="comment">// 数组大小，细节~</span></span><br><span class="line">	<span class="comment">// 遍历 names 数组</span></span><br><span class="line">	<span class="keyword">for</span> (String name : names) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			<span class="comment">// 获得 name 对应的类</span></span><br><span class="line">			Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);</span><br><span class="line">			<span class="comment">// 判断类是否实现自 type 类</span></span><br><span class="line">			Assert.isAssignable(type, instanceClass);</span><br><span class="line">			<span class="comment">// 获得构造方法</span></span><br><span class="line">			Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes);</span><br><span class="line">			<span class="comment">// 创建对象</span></span><br><span class="line">			T instance = (T) BeanUtils.instantiateClass(constructor, args);</span><br><span class="line">			instances.add(instance);</span><br><span class="line">		} <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot instantiate "</span> + type + <span class="string">" : "</span> + name, ex);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> instances;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较简单，就不多做解释了。</li>
</ul>
</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>AnnotationAwareOrderComparator#sort(List&lt;?&gt; list)</validateCode> 方法，排序对象们。例如说，类上有 <a href="https://www.jianshu.com/p/8442d21222ef" rel="external nofollow noopener noreferrer" target="_blank"><validateCode>@Order</validateCode></a> 注解。</li>
</ul>
<h2 id="2-2-run"><a href="#2-2-run" class="headerlink" title="2.2 run"></a>2.2 run</h2><p><validateCode>#run(String... args)</validateCode> 方法，运行 Spring 应用。代码如下：</p>
<blockquote>
<p>艿艿：这是一个饱满的方法，所以逻辑比较多哈。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 创建 StopWatch 对象，并启动。StopWatch 主要用于简单统计 run 启动过程的时长。</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 配置 headless 属性</span></span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 获得 SpringApplicationRunListener 的数组，并启动监听</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// &lt;3&gt; 创建  ApplicationArguments 对象</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// &lt;4&gt; 加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 application.properties 和外部的属性配置。</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// &lt;5&gt; 打印 Spring Banner</span></span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">// &lt;6&gt; 创建 Spring 容器。</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        <span class="comment">// &lt;7&gt; 异常报告器</span></span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(</span><br><span class="line">                SpringBootExceptionReporter.class,</span><br><span class="line">                <span class="keyword">new</span> Class[] { ConfigurableApplicationContext.class }, context);</span><br><span class="line">        <span class="comment">// &lt;8&gt; 主要是调用所有初始化类的 initialize 方法</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">                printedBanner);</span><br><span class="line">        <span class="comment">// &lt;9&gt; 初始化 Spring 容器。</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// &lt;10&gt; 执行 Spring 容器的初始化的后置逻辑。默认实现为空。</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// &lt;11&gt; 停止 StopWatch 统计时长</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// &lt;12&gt; 打印 Spring Boot 启动的时长日志。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) {</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// &lt;13&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器启动完成。</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// &lt;14&gt; 调用 ApplicationRunner 或者 CommandLineRunner 的运行方法。</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="comment">// &lt;14.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;15&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器运行中。</span></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        listeners.running(context);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">        <span class="comment">// &lt;15.1&gt; 如果发生异常，则进行处理，并抛出 IllegalStateException 异常</span></span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，创建 StopWatch 对象，并调用 <validateCode>StopWatch#run()</validateCode> 方法来启动。StopWatch 主要用于简单统计 run 启动过程的时长。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，配置 headless 属性。这个逻辑，可以无视，和 AWT 相关。</li>
<li><p><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>#getRunListeners(String[] args)</validateCode> 方法，获得 SpringApplicationRunListener 数组，并启动监听。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SpringApplicationRunListeners <span class="title">getRunListeners</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">	Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[] { SpringApplication.class, String[].class };</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationRunListeners(logger, getSpringFactoriesInstances(</span><br><span class="line">			SpringApplicationRunListener.class, types, <span class="keyword">this</span>, args));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>此处的 <validateCode>listeners</validateCode> 变量，如下图所示：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-07/03.jpg" alt="`listeners` 属性"></li>
<li>注意噢，此时是 SpringApplication<strong>Run</strong>Listener ，而不是我们看到 <validateCode>listeners</validateCode> 的 ApplicationListener 类型。详细的，我们在 <a href="#">「3. SpringApplicationRunListeners」</a> 中，在详细解析。</li>
</ul>
</li>
<li><p><validateCode>&lt;4&gt;</validateCode> 处，调用 <validateCode>#prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</validateCode> 方法，加载属性配置。执行完成后，所有的 environment 的属性都会加载进来，包括 <validateCode>application.properties</validateCode> 和外部的属性配置。详细的，胖友先一起跳到 <a href="#">「2.2.1 prepareEnvironment」</a> 中。</p>
</li>
<li><p><validateCode>&lt;5&gt;</validateCode> 处，调用 <validateCode>#printBanner(ConfigurableEnvironment environment)</validateCode> 方法，打印 Spring Banner 。效果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="validateCode"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___<span class="string">'_ __ _ _(_)_ __  __ _ \ \ \ \</span></span><br><span class="line"><span class="string">( ( )\___ | '</span>_ | <span class="string">'_| | '</span>_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  <span class="string">'  |____| .__|_| |_|_| |_\__, | / / / /</span></span><br><span class="line"><span class="string"> =========|_|==============|___/=/_/_/_/</span></span><br><span class="line"><span class="string"> :: Spring Boot ::</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的代码实现，就先不分析了。感兴趣的胖友，自己去瞅瞅。</li>
</ul>
</li>
<li><p><validateCode>&lt;6&gt;</validateCode> 处，调用 <validateCode>#createApplicationContext()</validateCode> 方法，创建 Spring 容器。详细解析，见 <a href="#">「2.2.2 createApplicationContext」</a> 。</p>
</li>
<li><validateCode>&lt;7&gt;</validateCode> 处，通过 <validateCode>#getSpringFactoriesInstances(Class&lt;T&gt; type)</validateCode> 方法，进行获得 SpringBootExceptionReporter 类型的对象数组。SpringBootExceptionReporter ，记录启动过程中的异常信息。<ul>
<li>此处，<validateCode>exceptionReporters</validateCode> 属性的结果如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-07/04.jpg" alt="`listeners` 属性"></li>
<li>关于 SpringBootExceptionReporter ，感兴趣的胖友，自己研究先。</li>
</ul>
</li>
<li><validateCode>&lt;8&gt;</validateCode> 处，调用 <validateCode>#prepareContext(...)</validateCode> 方法，主要是调用所有初始化类的 <validateCode>#initialize(...)</validateCode> 方法。详细解析，见 <a href="#">「2.2.3 prepareContext」</a> 。</li>
<li><validateCode>&lt;9&gt;</validateCode> 处，调用 <validateCode></validateCode>#refreshContext(ConfigurableApplicationContext context)` 方法，启动（刷新） Spring 容器。详细解析，见 <a href="#">「2.2.4 refreshContext」</a> 。</li>
<li><p><validateCode>&lt;10&gt;</validateCode> 处，调用 <validateCode>#afterRefresh(ConfigurableApplicationContext context, ApplicationArguments args)</validateCode> 方法，执行 Spring 容器的初始化的后置逻辑。<strong>默认实现为空</strong>。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterRefresh</span><span class="params">(ConfigurableApplicationContext context, ApplicationArguments args)</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><validateCode>&lt;11&gt;</validateCode> 处，停止 StopWatch 统计时长。</p>
</li>
<li><p><validateCode>&lt;12&gt;</validateCode> 处，打印 Spring Boot 启动的时长日志。效果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="validateCode"><pre><span class="line">2019-01-28 20:42:03.338  INFO 53001 --- [           main] c.iocoder.springboot.mvc.MVCApplication  : Started MVCApplication <span class="keyword">in</span> 20.893 seconds (JVM running <span class="keyword">for</span> 23.536)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><validateCode>&lt;13&gt;</validateCode> 处，调用 <validateCode>SpringApplicationRunListeners#started(ConfigurableApplicationContext context)</validateCode> 方法，通知 SpringApplicationRunListener 的数组，Spring 容器启动完成。</p>
</li>
<li><validateCode>&lt;14&gt;</validateCode> 处，调用 <validateCode>#callRunners(ApplicationContext context, ApplicationArguments args)</validateCode> 方法，调用 ApplicationRunner 或者 CommandLineRunner 的运行方法。详细解析，见 <a href="#">「2.2.5 callRunners」</a> 。<ul>
<li><validateCode>&lt;14.1&gt;</validateCode> 处，如果发生异常，则调用 <validateCode>#handleRunFailure(...)</validateCode> 方法，交给 SpringBootExceptionReporter 进行处理，并抛出 IllegalStateException 异常。</li>
</ul>
</li>
<li><validateCode>&lt;15&gt;</validateCode> 处，调用 <validateCode>SpringApplicationRunListeners#running(ConfigurableApplicationContext context)</validateCode> 方法，通知 SpringApplicationRunListener 的数组，Spring 容器运行中。<ul>
<li><validateCode>&lt;15.1&gt;</validateCode> 处，如果发生异常，则调用 <validateCode>#handleRunFailure(...)</validateCode> 方法，交给 SpringBootExceptionReporter 进行处理，并抛出 IllegalStateException 异常。</li>
</ul>
</li>
</ul>
<h3 id="2-2-1-prepareEnvironment"><a href="#2-2-1-prepareEnvironment" class="headerlink" title="2.2.1 prepareEnvironment"></a>2.2.1 prepareEnvironment</h3><blockquote>
<p>艿艿：这个方法，大体看下即可。</p>
</blockquote>
<p><validateCode>#prepareEnvironment(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</validateCode> 方法，加载属性配置。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">prepareEnvironment</span><span class="params">(SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments)</span> </span>{</span><br><span class="line">	<span class="comment">// Create and configure the environment</span></span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 ConfigurableEnvironment 对象，并进行配置</span></span><br><span class="line">	ConfigurableEnvironment environment = getOrCreateEnvironment();</span><br><span class="line">	configureEnvironment(environment, applicationArguments.getSourceArgs());</span><br><span class="line">	<span class="comment">// &lt;2&gt; 通知 SpringApplicationRunListener 的数组，环境变量已经准备完成。</span></span><br><span class="line">	listeners.environmentPrepared(environment);</span><br><span class="line">	<span class="comment">// &lt;3&gt; 绑定 environment 到 SpringApplication 上</span></span><br><span class="line">	bindToSpringApplication(environment);</span><br><span class="line">	<span class="comment">// &lt;4&gt; 如果非自定义 environment ，则根据条件转换</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.isCustomEnvironment) {</span><br><span class="line">		environment = <span class="keyword">new</span> EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;5&gt; 如果有 attach 到 environment 上的 MutablePropertySources ，则添加到 environment 的 PropertySource 中。</span></span><br><span class="line">	ConfigurationPropertySources.attach(environment);</span><br><span class="line">	<span class="keyword">return</span> environment;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#getOrCreateEnvironment()</validateCode> 方法，创建 ConfigurableEnvironment 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConfigurableEnvironment <span class="title">getOrCreateEnvironment</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="comment">// 已经存在，则进行返回</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 不存在，则根据 webApplicationType 类型，进行创建。</span></span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) {</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StandardServletEnvironment();</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StandardReactiveWebEnvironment();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据 <validateCode>webApplicationType</validateCode> 类型，会创建不同类型的 ConfigurableEnvironment 对象。</li>
<li>例如说，Servlet 需要考虑 <validateCode>&lt;servletContextInitParams /&gt;</validateCode> 和 <validateCode>&lt;servletConfigInitParams /&gt;</validateCode> 等配置参数。</li>
</ul>
</li>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#configureEnvironment(ConfigurableEnvironment environment, String[] args)</validateCode> 方法，配置 <validateCode>environment</validateCode> 变量。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line">   <span class="comment">// SpringApplication.java</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否添加共享的 ConversionService</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> addConversionService = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureEnvironment</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> </span>{</span><br><span class="line">   	<span class="comment">// &lt;1.1&gt; 设置 environment 的 conversionService 属性</span></span><br><span class="line">   	<span class="keyword">if</span> (<span class="keyword">this</span>.addConversionService) {</span><br><span class="line">   		ConversionService conversionService = ApplicationConversionService.getSharedInstance();</span><br><span class="line">   		environment.setConversionService((ConfigurableConversionService) conversionService);</span><br><span class="line">   	}</span><br><span class="line">   	<span class="comment">// &lt;1.2&gt; 增加 environment 的 PropertySource 属性源</span></span><br><span class="line">   	configurePropertySources(environment, args);</span><br><span class="line">   	<span class="comment">// &lt;1.3&gt; 配置 environment 的 activeProfiles 属性</span></span><br><span class="line">   	configureProfiles(environment, args);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1.1&gt;</validateCode> 处，设置 <validateCode>environment</validateCode> 的 <validateCode>conversionService</validateCode> 属性。可以暂时无视。感兴趣的胖友，可以看看 <a href="http://svip.iocoder.cn/Spring/PropertySource-and-Environment-and-Profile/">《【死磕 Spring】—— 环境 &amp; 属性：PropertySource、Environment、Profile》</a></li>
<li><p><validateCode>&lt;1.2&gt;</validateCode> 处，增加 <validateCode>environment</validateCode> 的 PropertySource 属性源。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line">   <span class="comment">// SpringApplication.java</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否添加 JVM 启动参数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> addCommandLineProperties = <span class="keyword">true</span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认的属性集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; defaultProperties;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configurePropertySources</span><span class="params">(ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">   		String[] args)</span> </span>{</span><br><span class="line">   	MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">   	<span class="comment">// 配置的 defaultProperties</span></span><br><span class="line">   	<span class="keyword">if</span> (<span class="keyword">this</span>.defaultProperties != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.defaultProperties.isEmpty()) {</span><br><span class="line">   		sources.addLast(<span class="keyword">new</span> MapPropertySource(<span class="string">"defaultProperties"</span>, <span class="keyword">this</span>.defaultProperties));</span><br><span class="line">   	}</span><br><span class="line">   	<span class="comment">// 来自启动参数的</span></span><br><span class="line">   	<span class="keyword">if</span> (<span class="keyword">this</span>.addCommandLineProperties &amp;&amp; args.length &gt; <span class="number">0</span>) {</span><br><span class="line">   		String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;</span><br><span class="line">   		<span class="keyword">if</span> (sources.contains(name)) { <span class="comment">// 已存在，就进行替换</span></span><br><span class="line">   			PropertySource&lt;?&gt; source = sources.get(name);</span><br><span class="line">   			CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(name);</span><br><span class="line">   			composite.addPropertySource(<span class="keyword">new</span> SimpleCommandLinePropertySource(</span><br><span class="line">   					<span class="string">"springApplicationCommandLineArgs"</span>, args));</span><br><span class="line">   			composite.addPropertySource(source);</span><br><span class="line">   			sources.replace(name, composite);</span><br><span class="line">   		} <span class="keyword">else</span> { <span class="comment">// 不存在，就进行添加</span></span><br><span class="line">   			sources.addFirst(<span class="keyword">new</span> SimpleCommandLinePropertySource(args));</span><br><span class="line">   		}</span><br><span class="line">   	}</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码上可以看出，可以根据配置的 <validateCode>defaultProperties</validateCode>、或者 JVM 启动参数，作为附加的 PropertySource 属性源。</li>
</ul>
</li>
<li><p><validateCode>&lt;1.3&gt;</validateCode> 处，配置 <validateCode>environment</validateCode> 的 <validateCode>activeProfiles</validateCode> 属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 附加的 profiles 的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; additionalProfiles = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureProfiles</span><span class="params">(ConfigurableEnvironment environment, String[] args)</span> </span>{</span><br><span class="line">	environment.getActiveProfiles(); <span class="comment">// ensure they are initialized 保证已经被初始化</span></span><br><span class="line">	<span class="comment">// But these ones should go first (last wins in a property key clash)</span></span><br><span class="line">	Set&lt;String&gt; profiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.additionalProfiles);</span><br><span class="line">	profiles.addAll(Arrays.asList(environment.getActiveProfiles()));</span><br><span class="line">	<span class="comment">// 设置 activeProfiles</span></span><br><span class="line">	environment.setActiveProfiles(StringUtils.toStringArray(profiles));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>不了解 Profile 的胖友，可以看看 <a href="https://my.oschina.net/u/1469495/blog/1522784" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot 激活 profile 的几种方式》</a> 文章。</li>
</ul>
</li>
</ul>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>SpringApplicationRunListeners#environmentPrepared(ConfigurableEnvironment environment)</validateCode> 方法，通知 SpringApplicationRunListener 的数组，环境变量已经准备完成。</p>
</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>#bindToSpringApplication(ConfigurableEnvironment environment)</validateCode> 方法，绑定 <validateCode>environment</validateCode> 到 SpringApplication 上。暂时不太知道用途。</li>
<li><validateCode>&lt;4&gt;</validateCode> 处，如果非自定义 <validateCode>environment</validateCode> ，则根据条件转换。默认情况下，<validateCode>isCustomEnvironment</validateCode> 为 <validateCode>false</validateCode> ，所以会执行这块逻辑。但是，一般情况下，返回的还是 <validateCode>environment</validateCode> 自身，所以可以无视这块逻辑先。</li>
<li><validateCode>&lt;5&gt;</validateCode> 处，调用 <validateCode>ConfigurationPropertySources#attach(Environment environment)</validateCode> <strong>静态</strong>方法，如果有 attach 到 <validateCode>environment</validateCode>上的 MutablePropertySources ，则添加到 <validateCode>environment</validateCode> 的 PropertySource 中。这块逻辑，也可以先无视。</li>
</ul>
<h3 id="2-2-2-createApplicationContext"><a href="#2-2-2-createApplicationContext" class="headerlink" title="2.2.2 createApplicationContext"></a>2.2.2 createApplicationContext</h3><p><validateCode>#createApplicationContext()</validateCode> 方法，创建 Spring 容器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for non-web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CONTEXT_CLASS = <span class="string">"org.springframework.context."</span></span><br><span class="line">		+ <span class="string">"annotation.AnnotationConfigApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = <span class="string">"org.springframework.boot."</span></span><br><span class="line">		+ <span class="string">"web.servlet.context.AnnotationConfigServletWebServerApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The class name of application context that will be used by default for reactive web</span></span><br><span class="line"><span class="comment"> * environments.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REACTIVE_WEB_CONTEXT_CLASS = <span class="string">"org.springframework."</span></span><br><span class="line">		+ <span class="string">"boot.web.reactive.context.AnnotationConfigReactiveWebServerApplicationContext"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 根据 webApplicationType 类型，获得 ApplicationContext 类型</span></span><br><span class="line">	Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">	<span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			<span class="keyword">switch</span> (<span class="keyword">this</span>.webApplicationType) {</span><br><span class="line">			<span class="keyword">case</span> SERVLET:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REACTIVE:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable create a default ApplicationContext, "</span> + <span class="string">"please specify an ApplicationContextClass"</span>, ex);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 创建 ApplicationContext 对象</span></span><br><span class="line">	<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>根据 <validateCode>webApplicationType</validateCode> 类型，获得对应的 ApplicationContext 对象。</li>
</ul>
<h3 id="2-2-3-prepareContext"><a href="#2-2-3-prepareContext" class="headerlink" title="2.2.3 prepareContext"></a>2.2.3 prepareContext</h3><p><validateCode>#prepareContext(ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</validateCode> 方法，准备 ApplicationContext 对象，主要是初始化它的一些属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span></span><br><span class="line"><span class="function"><span class="params">        ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 设置 context 的 environment 属性</span></span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 设置 context 的一些属性</span></span><br><span class="line">    postProcessApplicationContext(context);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 初始化 ApplicationContextInitializer</span></span><br><span class="line">    applyInitializers(context);</span><br><span class="line">    <span class="comment">// &lt;4&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器准备完成。</span></span><br><span class="line">    listeners.contextPrepared(context);</span><br><span class="line">    <span class="comment">// &lt;5&gt; 打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) {</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Add boot specific singleton beans</span></span><br><span class="line">    <span class="comment">// &lt;6&gt; 设置 beanFactory 的属性</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) {</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) {</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory).setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    <span class="comment">// &lt;7&gt; 加载 BeanDefinition 们</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">// &lt;8&gt; 通知 SpringApplicationRunListener 的数组，Spring 容器加载完成。</span></span><br><span class="line">    listeners.contextLoaded(context);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这个方法，还是蛮长的，主要是给 <validateCode>context</validateCode> 的属性做赋值，以及 ApplicationContextInitializer 的初始化。</li>
<li><validateCode>&lt;1&gt;</validateCode> 处，设置 <validateCode>context</validateCode> 的 <validateCode>environment</validateCode> 属性。</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#postProcessApplicationContext(ConfigurableApplicationContext context)</validateCode> 方法，设置 <validateCode>context</validateCode> 的一些属性。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessApplicationContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) {</span><br><span class="line">		context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, <span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) {</span><br><span class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> GenericApplicationContext) {</span><br><span class="line">			((GenericApplicationContext) context).setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (context <span class="keyword">instanceof</span> DefaultResourceLoader) {</span><br><span class="line">			((DefaultResourceLoader) context).setClassLoader(<span class="keyword">this</span>.resourceLoader.getClassLoader());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.addConversionService) {</span><br><span class="line">		context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>#applyInitializers(ConfigurableApplicationContext context)</validateCode> 方法，初始化 ApplicationContextInitializer 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="comment">// 遍历 ApplicationContextInitializer 数组</span></span><br><span class="line">	<span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) {</span><br><span class="line">	    <span class="comment">// 校验 ApplicationContextInitializer 的泛型非空</span></span><br><span class="line">		Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(</span><br><span class="line">				initializer.getClass(), ApplicationContextInitializer.class);</span><br><span class="line">		Assert.isInstanceOf(requiredType, context, <span class="string">"Unable to call initializer."</span>);</span><br><span class="line">		<span class="comment">// 初始化 ApplicationContextInitializer</span></span><br><span class="line">		initializer.initialize(context);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>遍历 ApplicationContextInitializer 数组，逐个调用 <validateCode>ApplicationContextInitializer#initialize(context)</validateCode> 方法，进行初始化。</li>
</ul>
</li>
<li><validateCode>&lt;4&gt;</validateCode> 处，调用 <validateCode>SpringApplicationRunListeners#contextPrepared(ConfigurableApplicationContext context)</validateCode> 方法，通知 SpringApplicationRunListener 的数组，Spring 容器准备完成。</li>
<li><p><validateCode>&lt;5&gt;</validateCode> 处，打印日志。效果如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="validateCode"><pre><span class="line">2019-01-28 17:53:31.600  INFO 21846 --- [           main] c.iocoder.springboot.mvc.MVCApplication  : Starting MVCApplication on MacBook-Pro-5.local with PID 21846 (/Users/yunai/Java/spring-boot/spring-boot-tests/spring-boot-yunai-tests/spring-boot-yunai-mvc-tests/target/classes started by yunai <span class="keyword">in</span> /Users/yunai/Java/spring-boot)</span><br><span class="line">2019-01-28 17:53:40.028  INFO 21846 --- [           main] c.iocoder.springboot.mvc.MVCApplication  : The following profiles are active: prod</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>具体的方法逻辑，胖友自己瞅瞅哈。</li>
</ul>
</li>
<li><p><validateCode>&lt;6&gt;</validateCode> 处，设置 <validateCode>beanFactory</validateCode> 的属性。</p>
</li>
<li><p><validateCode>&lt;7&gt;</validateCode> 处，调用 <validateCode>#load(ApplicationContext context, Object[] sources)</validateCode> 方法，加载 BeanDefinition 们。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(ApplicationContext context, Object[] sources)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">		logger.debug(<span class="string">"Loading source "</span> + StringUtils.arrayToCommaDelimitedString(sources));</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;1&gt; 创建 BeanDefinitionLoader 对象</span></span><br><span class="line">	BeanDefinitionLoader loader = createBeanDefinitionLoader(getBeanDefinitionRegistry(context), sources);</span><br><span class="line">	<span class="comment">// &lt;2&gt; 设置 loader 的属性</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.beanNameGenerator != <span class="keyword">null</span>) {</span><br><span class="line">		loader.setBeanNameGenerator(<span class="keyword">this</span>.beanNameGenerator);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) {</span><br><span class="line">		loader.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) {</span><br><span class="line">		loader.setEnvironment(<span class="keyword">this</span>.environment);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;3&gt; 执行 BeanDefinition 加载</span></span><br><span class="line">	loader.load();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#getBeanDefinitionRegistry(ApplicationContext context)</validateCode> 方法，创建 BeanDefinitionRegistry 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionRegistry <span class="title">getBeanDefinitionRegistry</span><span class="params">(ApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="keyword">if</span> (context <span class="keyword">instanceof</span> BeanDefinitionRegistry) {</span><br><span class="line">		<span class="keyword">return</span> (BeanDefinitionRegistry) context;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (context <span class="keyword">instanceof</span> AbstractApplicationContext) {</span><br><span class="line">		<span class="keyword">return</span> (BeanDefinitionRegistry) ((AbstractApplicationContext) context)</span><br><span class="line">				.getBeanFactory();</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not locate BeanDefinitionRegistry"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关于 BeanDefinitionRegistry 类，暂时不需要深入了解。感兴趣的胖友，可以看看 <a href="http://svip.iocoder.cn/Spring/IoC-BeanDefinitionRegistry/">《【死磕 Spring】—— IoC 之 BeanDefinition 注册表：BeanDefinitionRegistry》</a> 文章。</li>
</ul>
</li>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#createBeanDefinitionLoader(BeanDefinitionRegistry registry, Object[] sources)</validateCode> 方法，创建 <validateCode>org.springframework.boot.BeanDefinitionLoader</validateCode> 对象。关于它，后续的文章，详细解析。</p>
</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，设置 <validateCode>loader</validateCode> 的属性。 </li>
<li><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>BeanDefinitionLoader#load()</validateCode> 方法，执行 BeanDefinition 加载。关于这一块，胖友感兴趣，先简单看看 <a href="http://svip.iocoder.cn/Spring/IoC-load-BeanDefinitions/">《【死磕 Spring】—— IoC 之加载 BeanDefinition》</a> 文章。 </li>
</ul>
</li>
<li><p><validateCode>&lt;8&gt;</validateCode> 处，调用 <validateCode>SpringApplicationRunListeners#contextLoaded(ConfigurableApplicationContext context)</validateCode> 方法，通知 SpringApplicationRunListener 的数组，Spring 容器加载完成。</p>
</li>
</ul>
<h3 id="2-2-4-refreshContext"><a href="#2-2-4-refreshContext" class="headerlink" title="2.2.4 refreshContext"></a>2.2.4 refreshContext</h3><p><validateCode>#refreshContext(ConfigurableApplicationContext context)</validateCode> 方法，启动（刷新） Spring 容器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否注册 ShutdownHook 钩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> registerShutdownHook = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="comment">// &lt;1&gt; 开启（刷新）Spring 容器</span></span><br><span class="line">	refresh(context);</span><br><span class="line">	<span class="comment">// &lt;2&gt; 注册 ShutdownHook 钩子</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.registerShutdownHook) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			context.registerShutdownHook();</span><br><span class="line">		} <span class="keyword">catch</span> (AccessControlException ex) {</span><br><span class="line">			<span class="comment">// Not allowed in some environments.</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#refresh(ApplicationContext applicationContext)</validateCode> 方法，开启（刷新）Spring 容器。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">(ApplicationContext applicationContext)</span> </span>{</span><br><span class="line">	<span class="comment">// 断言，判断 applicationContext 是 AbstractApplicationContext 的子类</span></span><br><span class="line">	Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);</span><br><span class="line">	<span class="comment">// 启动（刷新） AbstractApplicationContext</span></span><br><span class="line">	((AbstractApplicationContext) applicationContext).refresh();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>调用 <validateCode>AbstractApplicationContext#refresh()</validateCode> 方法，启动（刷新）Spring 容器。<ul>
<li><validateCode>AbstractApplicationContext#refresh()</validateCode> 方法，胖友可以看看 <a href="http://svip.iocoder.cn/Spring/ApplicationContext/">《【死磕 Spring】—— ApplicationContext 相关接口架构分析》</a> 文章。</li>
<li>这里，可以触发 Spring Boot 的自动配置的功能。关于这一块，我们会在下一篇文章，详细解析。</li>
</ul>
</li>
</ul>
</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>ConfigurableApplicationContext#registerShutdownHook()</validateCode> 方法，注册 ShutdownHook 钩子。这个钩子，主要用于 Spring 应用的关闭时，销毁相应的 Bean 们。</li>
</ul>
<h3 id="2-2-5-callRunners"><a href="#2-2-5-callRunners" class="headerlink" title="2.2.5 callRunners"></a>2.2.5 callRunners</h3><p><validateCode>#callRunners(ApplicationContext context, ApplicationArguments args)</validateCode> 方法，调用 ApplicationRunner 或者 CommandLineRunner 的运行方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunners</span><span class="params">(ApplicationContext context, ApplicationArguments args)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得所有 Runner 们</span></span><br><span class="line">    List&lt;Object&gt; runners = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// &lt;1.1&gt; 获得所有 ApplicationRunner Bean 们</span></span><br><span class="line">    runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());</span><br><span class="line">    <span class="comment">// &lt;1.2&gt; 获得所有 CommandLineRunner Bean 们</span></span><br><span class="line">    runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());</span><br><span class="line">    <span class="comment">// &lt;1.3&gt; 排序 runners</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(runners);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 遍历 Runner 数组，执行逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (Object runner : <span class="keyword">new</span> LinkedHashSet&lt;&gt;(runners)) {</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> ApplicationRunner) {</span><br><span class="line">            callRunner((ApplicationRunner) runner, args);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">instanceof</span> CommandLineRunner) {</span><br><span class="line">            callRunner((CommandLineRunner) runner, args);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，获得所有 Runner 们，并进行排序。</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，遍历 Runner 数组，执行逻辑。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(ApplicationRunner runner, ApplicationArguments args)</span> </span>{</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		(runner).run(args);</span><br><span class="line">	} <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute ApplicationRunner"</span>, ex);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callRunner</span><span class="params">(CommandLineRunner runner, ApplicationArguments args)</span> </span>{</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		(runner).run(args.getSourceArgs());</span><br><span class="line">	} <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to execute CommandLineRunner"</span>, ex);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>关于 Runner 功能的使用，可以看看 <a href="https://www.kancloud.cn/letiantian/learn-spring-boot/697172" rel="external nofollow noopener noreferrer" target="_blank">《ApplicationRunner 接口》</a> 和 <a href="https://www.kancloud.cn/letiantian/learn-spring-boot/696203" rel="external nofollow noopener noreferrer" target="_blank">《CommandLineRunner 接口》</a> 文档。</p>
<h1 id="3-SpringApplicationRunListeners"><a href="#3-SpringApplicationRunListeners" class="headerlink" title="3. SpringApplicationRunListeners"></a>3. SpringApplicationRunListeners</h1><p><validateCode>org.springframework.boot.SpringApplicationRunListeners</validateCode> ，SpringApplicationRunListener 数组的封装。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplicationRunListeners.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationRunListeners</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Log log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SpringApplicationRunListener 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SpringApplicationRunListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">    SpringApplicationRunListeners(Log log,</span><br><span class="line">            Collection&lt;? extends SpringApplicationRunListener&gt; listeners) {</span><br><span class="line">        <span class="keyword">this</span>.log = log;</span><br><span class="line">        <span class="keyword">this</span>.listeners = <span class="keyword">new</span> ArrayList&lt;&gt;(listeners);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            listener.starting();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            listener.environmentPrepared(environment);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            listener.contextPrepared(context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            listener.contextLoaded(context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            listener.started(context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            listener.running(context);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (SpringApplicationRunListener listener : <span class="keyword">this</span>.listeners) {</span><br><span class="line">            callFailedListener(listener, context, exception);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailedListener</span><span class="params">(SpringApplicationRunListener listener, ConfigurableApplicationContext context, Throwable exception)</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            listener.failed(context, exception);</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">            <span class="keyword">if</span> (exception == <span class="keyword">null</span>) {</span><br><span class="line">                ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) {</span><br><span class="line">                <span class="keyword">this</span>.log.error(<span class="string">"Error handling failed"</span>, ex);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                String message = ex.getMessage();</span><br><span class="line">                message = (message != <span class="keyword">null</span>) ? message : <span class="string">"no error message"</span>;</span><br><span class="line">                <span class="keyword">this</span>.log.warn(<span class="string">"Error handling failed ("</span> + message + <span class="string">")"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-1-SpringApplicationRunListener"><a href="#3-1-SpringApplicationRunListener" class="headerlink" title="3.1 SpringApplicationRunListener"></a>3.1 SpringApplicationRunListener</h2><p><validateCode>org.springframework.boot.SpringApplicationRunListener</validateCode> ，SpringApplication 运行的监听器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplicationRunListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationRunListener</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called immediately when the run method has first started. Can be used for very</span></span><br><span class="line"><span class="comment">	 * early initialization.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called once the environment has been prepared, but before the</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@link</span> ApplicationContext} has been created.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> environment the environment</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called once the {<span class="doctag">@link</span> ApplicationContext} has been created and prepared, but</span></span><br><span class="line"><span class="comment">	 * before sources have been loaded.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the application context</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called once the application context has been loaded but before it has been</span></span><br><span class="line"><span class="comment">	 * refreshed.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the application context</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The context has been refreshed and the application has started but</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@link</span> CommandLineRunner CommandLineRunners} and {<span class="doctag">@link</span> ApplicationRunner</span></span><br><span class="line"><span class="comment">	 * ApplicationRunners} have not been called.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called immediately before the run method finishes, when the application context has</span></span><br><span class="line"><span class="comment">	 * been refreshed and all {<span class="doctag">@link</span> CommandLineRunner CommandLineRunners} and</span></span><br><span class="line"><span class="comment">	 * {<span class="doctag">@link</span> ApplicationRunner ApplicationRunners} have been called.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Called when a failure occurs when running the application.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the application context or {<span class="doctag">@validateCode</span> null} if a failure occurred before</span></span><br><span class="line"><span class="comment">	 * the context was created</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> exception the failure</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 2.0.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>目前，SpringApplicationRunListener 的实现类，只有 EventPublishingRunListener 类。</p>
<h2 id="3-2-EventPublishingRunListener"><a href="#3-2-EventPublishingRunListener" class="headerlink" title="3.2 EventPublishingRunListener"></a>3.2 EventPublishingRunListener</h2><p><validateCode>org.springframework.boot.context.event.EventPublishingRunListener</validateCode> ，实现 SpringApplicationRunListener、Ordered 接口，将 SpringApplicationRunListener 监听到的事件，转换成对应的 SpringApplicationEvent 事件，发布到监听器们。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// EventPublishingRunListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventPublishingRunListener</span> <span class="keyword">implements</span> <span class="title">SpringApplicationRunListener</span>, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 应用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SpringApplication application;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件广播器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SimpleApplicationEventMulticaster initialMulticaster;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventPublishingRunListener</span><span class="params">(SpringApplication application, String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.application = application;</span><br><span class="line">        <span class="keyword">this</span>.args = args;</span><br><span class="line">        <span class="comment">// 创建 SimpleApplicationEventMulticaster 对象</span></span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster();</span><br><span class="line">        <span class="comment">// 添加应用的监听器们，到 initialMulticaster 中</span></span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : application.getListeners()) {</span><br><span class="line">            <span class="keyword">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">starting</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationStartingEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// ApplicationEnvironmentPreparedEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationEnvironmentPreparedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, environment));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// ApplicationContextInitializedEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationContextInitializedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// ApplicationPreparedEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : <span class="keyword">this</span>.application.getListeners()) {</span><br><span class="line">            <span class="keyword">if</span> (listener <span class="keyword">instanceof</span> ApplicationContextAware) {</span><br><span class="line">                ((ApplicationContextAware) listener).setApplicationContext(context);</span><br><span class="line">            }</span><br><span class="line">            context.addApplicationListener(listener);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> ApplicationPreparedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// ApplicationStartedEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">started</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> ApplicationStartedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> ApplicationReadyEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// ApplicationFailedEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>{</span><br><span class="line">        ApplicationFailedEvent event = <span class="keyword">new</span> ApplicationFailedEvent(<span class="keyword">this</span>.application, <span class="keyword">this</span>.args, context, exception);</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span> &amp;&amp; context.isActive()) {</span><br><span class="line">            <span class="comment">// Listeners have been registered to the application context so we should</span></span><br><span class="line">            <span class="comment">// use it at this point if we can</span></span><br><span class="line">            context.publishEvent(event);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// An inactive context may not have a multicaster so we use our multicaster to</span></span><br><span class="line">            <span class="comment">// call all of the context's listeners instead</span></span><br><span class="line">            <span class="keyword">if</span> (context <span class="keyword">instanceof</span> AbstractApplicationContext) {</span><br><span class="line">                <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : ((AbstractApplicationContext) context)</span><br><span class="line">                        .getApplicationListeners()) {</span><br><span class="line">                    <span class="keyword">this</span>.initialMulticaster.addApplicationListener(listener);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">this</span>.initialMulticaster.setErrorHandler(<span class="keyword">new</span> LoggingErrorHandler());</span><br><span class="line">            <span class="keyword">this</span>.initialMulticaster.multicastEvent(event);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingErrorHandler</span> <span class="keyword">implements</span> <span class="title">ErrorHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Log logger = LogFactory.getLog(EventPublishingRunListener.class);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleError</span><span class="params">(Throwable throwable)</span> </span>{</span><br><span class="line">            logger.warn(<span class="string">"Error calling ApplicationEventListener"</span>, throwable);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>代码比较简单，胖友自己瞅瞅就明白了。</li>
<li>通过这样的方式，可以很方便的将 SpringApplication 启动的各种事件，方便的修改成对应的 SpringApplicationEvent 事件。这样，我们就可以不需要修改 SpringApplication 的代码。或者说，我们认为 EventPublishingRunListener 是一个“<strong>转换器</strong>”。</li>
</ul>
<p>关于 Spring Boot 的事件，可以看看 <a href="https://www.kancloud.cn/letiantian/learn-spring-boot/712108" rel="external nofollow noopener noreferrer" target="_blank">《事件监听与发布》</a> 文章。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>整块代码略微有点长，胖友一定一定一定自己调试下。总的来说，逻辑并不复杂，是吧？是吧！</p>
<p>参考和推荐如下文章：</p>
<ul>
<li><p>快乐崇拜 <a href="https://gitbook.cn/books/5a445f030173cb29d2041d61/index.html" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot 源码深入分析》</a></p>
<blockquote>
<p>需要付费 3 块钱。你看，艿艿为了写好源码解析，还是去学习了下别人的博客。</p>
</blockquote>
</li>
<li><p>老田 <a href="http://www.54tianzhisheng.cn/2018/04/30/springboot_SpringApplication/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot 2.0 系列文章(七)：SpringApplication 深入探索》</a></p>
</li>
<li>oldflame-Jm <a href="https://blog.csdn.net/jamet/article/details/77413189" rel="external nofollow noopener noreferrer" target="_blank">《Spring boot源码分析-SpringApplication启动（1）》</a></li>
<li>dm_vincent <ul>
<li><a href="https://blog.csdn.net/dm_vincent/article/details/76735888" rel="external nofollow noopener noreferrer" target="_blank">《[Spring Boot] 1. Spring Boot 启动过程源码分析》</a></li>
<li><a href="https://blog.csdn.net/dm_vincent/article/details/77151122" rel="external nofollow noopener noreferrer" target="_blank">《[Spring Boot] 2. Spring Boot 启动过程定制化》</a> </li>
</ul>
</li>
<li>一个努力的码农<blockquote>
<p>设计 Spring Framework 的部分，他也写了一些~</p>
<ul>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78914752" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析2-SpringApplication初始化》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78914803" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析3-SpringApplication#run》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78914944" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析4-SpringApplication#run第4步》</a> </li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78915135" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析5-SpringApplication#run第5步》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78915181" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析6-SpringApplication#run第6步》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78915189" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析7-SpringApplication#run第7步》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78915211" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析8-SpringApplication#run第8步》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78915221" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析9-SpringApplication#run第9步》</a></li>
<li><a href="https://blog.csdn.net/qq_26000415/article/details/78915234" rel="external nofollow noopener noreferrer" target="_blank">《spring boot 源码解析10-SpringApplication#run第10-13步》</a></li>
</ul>
</blockquote>
</li>
</ul>




</div>