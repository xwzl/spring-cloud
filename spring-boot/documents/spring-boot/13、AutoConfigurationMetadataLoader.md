<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来补充 <a href="http://svip.iocoder.cn/Spring-Boot/AutoConfiguration">《精尽 Spring Boot 源码分析 —— 自动配置》</a> 文章，并未详细解析的 AutoConfigurationMetadataLoader 。在 SpringApplication 中，我们可以看到 <validateCode>AutoConfigurationImportSelector.AutoConfigurationGroup#loadMetadata(ClassLoader classLoader, String path)</validateCode> 方法中，加载自动配置类（AutoConfiguration）的元数据，是如下一段代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigurationImportSelector.AutoConfigurationGroup.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 获得 AutoConfigurationMetadata 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AutoConfigurationMetadata <span class="title">getAutoConfigurationMetadata</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 不存在，则进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.autoConfigurationMetadata == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">this</span>.autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 存在，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.autoConfigurationMetadata;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在内部，会调用 <validateCode>AutoConfigurationMetadataLoader#loadMetadata(ClassLoader classLoader)</validateCode> 方法，加载 AutoConfigurationMetadata 对象。</li>
<li>而我们知道，后续会基于返回的 AutoConfigurationMetadata 对象，进行 AutoConfiguration 类的<strong>过滤</strong>，从而避免不符合条件的 AutoConfiguration 类的字节码，加载到 JVM 中。那么是怎么做到的呢？我们接着来看 <a href="#">「2. AutoConfigurationMetadataLoader」</a> 。</li>
</ul>
<h1 id="2-AutoConfigurationMetadataLoader"><a href="#2-AutoConfigurationMetadataLoader" class="headerlink" title="2. AutoConfigurationMetadataLoader"></a>2. AutoConfigurationMetadataLoader</h1><p><validateCode>org.springframework.boot.autoconfigure.AutoConfigurationMetadataLoader</validateCode> ，AutoConfigurationMetadata 加载器。其类上的注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal utility used to load {<span class="doctag">@link</span> AutoConfigurationMetadata}.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-1-loadMetadata"><a href="#2-1-loadMetadata" class="headerlink" title="2.1 loadMetadata"></a>2.1 loadMetadata</h2><p><validateCode>#loadMetadata(ClassLoader classLoader)</validateCode> <strong>静态</strong>方法，加载 AutoConfigurationMetadata 。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigurationMetadataLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"META-INF/"</span> + <span class="string">"spring-autoconfigure-metadata.properties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AutoConfigurationMetadata <span class="title">loadMetadata</span><span class="params">(ClassLoader classLoader)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> loadMetadata(classLoader, PATH);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> AutoConfigurationMetadata <span class="title">loadMetadata</span><span class="params">(ClassLoader classLoader, String path)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// &lt;1&gt; 获得 PATH 对应的 URL 们</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span>) ? classLoader.getResources(path) : ClassLoader.getSystemResources(path);</span><br><span class="line">        <span class="comment">// &lt;2&gt; 遍历 URL 数组，读取到 properties 中</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) {</span><br><span class="line">            properties.putAll(PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(urls.nextElement())));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// &lt;3&gt; 将 properties 转换成 PropertiesAutoConfigurationMetadata 对象</span></span><br><span class="line">        <span class="keyword">return</span> loadMetadata(properties);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load @ConditionalOnClass location ["</span> + path + <span class="string">"]"</span>, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，获得 <validateCode>PATH</validateCode> 对应的 URL 们，而 <validateCode>PATH</validateCode> 就是 <validateCode>"META-INF/spring-autoconfigure-metadata.properties"</validateCode> 文件。这样，我们就可以避免去 AutoConfiguration 类上，读取其 Condition 条件了，从而避免将不符合条件的 AutoConfiguration 类的字节码，加载到 JVM 中。那么，此时就会有一个疑问，<validateCode>"META-INF/spring-autoconfigure-metadata.properties"</validateCode> 是怎么来的呢？答案我们在 <a href="#">「3. AutoConfigureAnnotationProcessor」</a> 中说。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，遍历 URL 数组，读取到 <validateCode>properties</validateCode> 中。</li>
<li><p><validateCode>&lt;3&gt;</validateCode> 处，调用 <validateCode>#loadMetadata(Properties properties)</validateCode> 方法，将 <validateCode>properties</validateCode> 转换成 PropertiesAutoConfigurationMetadata 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigurationMetadataLoader.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> AutoConfigurationMetadata <span class="title">loadMetadata</span><span class="params">(Properties properties)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PropertiesAutoConfigurationMetadata(properties);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关于 PropertiesAutoConfigurationMetadata 类，在 <a href="#">「2.2 」</a> 中看。 </li>
</ul>
</li>
</ul>
<h2 id="2-2-PropertiesAutoConfigurationMetadata"><a href="#2-2-PropertiesAutoConfigurationMetadata" class="headerlink" title="2.2 PropertiesAutoConfigurationMetadata"></a>2.2 PropertiesAutoConfigurationMetadata</h2><p>PropertiesAutoConfigurationMetadata ，是 AutoConfigurationMetadataLoader 的内部静态类，实现 AutoConfigurationMetadata 接口，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigurationMetadataLoader#PropertiesAutoConfigurationMetadata.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> AutoConfigurationMetadata} implementation backed by a properties file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesAutoConfigurationMetadata</span> <span class="keyword">implements</span> <span class="title">AutoConfigurationMetadata</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Properties 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Properties properties;</span><br><span class="line"></span><br><span class="line">    PropertiesAutoConfigurationMetadata(Properties properties) {</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wasProcessed</span><span class="params">(String className)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.properties.containsKey(className);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">(String className, String key)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> getInteger(className, key, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getInteger</span><span class="params">(String className, String key, Integer defaultValue)</span> </span>{</span><br><span class="line">        String value = get(className, key);</span><br><span class="line">        <span class="keyword">return</span> (value != <span class="keyword">null</span>) ? Integer.valueOf(value) : defaultValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSet</span><span class="params">(String className, String key)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> getSet(className, key, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSet</span><span class="params">(String className, String key, Set&lt;String&gt; defaultValue)</span> </span>{</span><br><span class="line">        String value = get(className, key);</span><br><span class="line">        <span class="keyword">return</span> (value != <span class="keyword">null</span>) ? StringUtils.commaDelimitedListToSet(value) : defaultValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String className, String key)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> get(className, key, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String className, String key, String defaultValue)</span> </span>{</span><br><span class="line">        String value = <span class="keyword">this</span>.properties.getProperty(className + <span class="string">"."</span> + key);</span><br><span class="line">        <span class="keyword">return</span> (value != <span class="keyword">null</span>) ? value : defaultValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-AutoConfigureAnnotationProcessor"><a href="#3-AutoConfigureAnnotationProcessor" class="headerlink" title="3. AutoConfigureAnnotationProcessor"></a>3. AutoConfigureAnnotationProcessor</h1><p>在 Spring Boot 的源码中，我们如果去检索 <validateCode>"spring-autoconfigure-metadata.properties"</validateCode> 文件，然而并找不到。是不是感觉很奇怪。于是乎，艿艿在搜索了一些网络的上的资料，原来是需要引入 <validateCode>spring-boot-autoconfigure-processor</validateCode> 依赖。这样，它的 AutoConfigureAnnotationProcessor 类，就会自动根据 AutoConfiguration 类的条件，生成 <validateCode>"META-INF/spring-autoconfigure-metadata.properties"</validateCode> 文件。</p>
<p>那么，此时又会有一个疑惑，那是什么时候生成呢？AutoConfigureAnnotationProcessor 继承自 <validateCode>javax.annotation.processing.AbstractProcessor</validateCode> 类，它可以在<strong>编译时</strong>，扫描和处理注解（Annotation），从而生成 <validateCode>"META-INF/spring-autoconfigure-metadata.properties"</validateCode> 文件。😈 很有意思。</p>
<blockquote>
<p>FROM <a href="https://www.race604.com/annotation-processing/" rel="external nofollow noopener noreferrer" target="_blank">《Java 注解处理器》</a></p>
<p>注解处理器（Annotation Processor）是<strong>javac</strong>的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以对自定义注解，并注册相应的注解处理器。到这里，我假设你已经知道什么是注解，并且知道怎么申明的一个注解。如果你不熟悉注解，你可以在这<a href="http://docs.oracle.com/javase/tutorial/java/annotations/index.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>中得到更多信息。注解处理器在Java 5开始就有了，但是从Java 6（2006年12月发布）开始才有可用的API。过了一些时间，Java世界才意识到注解处理器的强大作用，所以它到最近几年才流行起来。</p>
</blockquote>
<p>那么，我们开始撸撸 AutoConfigureAnnotationProcessor 的源码吧。</p>
<p><validateCode>org.springframework.boot.autoconfigureprocessor.AutoConfigureAnnotationProcessor</validateCode> ，继承 AbstractProcessor 抽象类，根据 AutoConfiguration 类的条件，生成 <validateCode>"META-INF/spring-autoconfigure-metadata.properties"</validateCode> 文件。其类上注释如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation processor to store certain annotations from auto-configuration classes in a</span></span><br><span class="line"><span class="comment"> * property file.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解名和全类名的映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * KEY：注解名</span></span><br><span class="line"><span class="comment"> * VALUE：全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; annotations;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解名和 ValueExtractor 的映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * KEY：注解名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ValueExtractor&gt; valueExtractors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扫描和处理注解（Annotation），生成的 Properties 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AutoConfigureAnnotationProcessor</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 初始化 annotations 属性</span></span><br><span class="line">    Map&lt;String, String&gt; annotations = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    addAnnotations(annotations);</span><br><span class="line">    <span class="keyword">this</span>.annotations = Collections.unmodifiableMap(annotations);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 初始化 valueExtractors 属性</span></span><br><span class="line">    Map&lt;String, ValueExtractor&gt; valueExtractors = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    addValueExtractors(valueExtractors);</span><br><span class="line">    <span class="keyword">this</span>.valueExtractors = Collections.unmodifiableMap(valueExtractors);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>annotations</validateCode> 属性，注解名和全类名的映射。在 <validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#addAnnotations(Map&lt;String, String&gt; annotations)</validateCode> 方法，进行初始化。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addAnnotations</span><span class="params">(Map&lt;String, String&gt; annotations)</span> </span>{</span><br><span class="line">	<span class="comment">// 条件</span></span><br><span class="line">	annotations.put(<span class="string">"Configuration"</span>, <span class="string">"org.springframework.context.annotation.Configuration"</span>);</span><br><span class="line">	annotations.put(<span class="string">"ConditionalOnClass"</span>, <span class="string">"org.springframework.boot.autoconfigure.condition.ConditionalOnClass"</span>);</span><br><span class="line">	annotations.put(<span class="string">"ConditionalOnBean"</span>, <span class="string">"org.springframework.boot.autoconfigure.condition.ConditionalOnBean"</span>);</span><br><span class="line">	annotations.put(<span class="string">"ConditionalOnSingleCandidate"</span>, <span class="string">"org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate"</span>);</span><br><span class="line">	annotations.put(<span class="string">"ConditionalOnWebApplication"</span>, <span class="string">"org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication"</span>);</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	annotations.put(<span class="string">"AutoConfigureBefore"</span>, <span class="string">"org.springframework.boot.autoconfigure.AutoConfigureBefore"</span>);</span><br><span class="line">	annotations.put(<span class="string">"AutoConfigureAfter"</span>, <span class="string">"org.springframework.boot.autoconfigure.AutoConfigureAfter"</span>);</span><br><span class="line">	annotations.put(<span class="string">"AutoConfigureOrder"</span>, <span class="string">"org.springframework.boot.autoconfigure.AutoConfigureOrder"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><validateCode>valueExtractors</validateCode> 属性，注解名和 ValueExtractor 的映射。在 <validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#addValueExtractors(Map&lt;String, ValueExtractor&gt; attributes)</validateCode> 方法，进行初始化。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addValueExtractors</span><span class="params">(Map&lt;String, ValueExtractor&gt; attributes)</span> </span>{</span><br><span class="line">    attributes.put(<span class="string">"Configuration"</span>, ValueExtractor.allFrom(<span class="string">"value"</span>));</span><br><span class="line">    attributes.put(<span class="string">"ConditionalOnClass"</span>, <span class="keyword">new</span> OnClassConditionValueExtractor());</span><br><span class="line">    attributes.put(<span class="string">"ConditionalOnBean"</span>, <span class="keyword">new</span> OnBeanConditionValueExtractor());</span><br><span class="line">    attributes.put(<span class="string">"ConditionalOnSingleCandidate"</span>, <span class="keyword">new</span> OnBeanConditionValueExtractor());</span><br><span class="line">    attributes.put(<span class="string">"ConditionalOnWebApplication"</span>, ValueExtractor.allFrom(<span class="string">"type"</span>));</span><br><span class="line">    attributes.put(<span class="string">"AutoConfigureBefore"</span>, ValueExtractor.allFrom(<span class="string">"value"</span>, <span class="string">"name"</span>));</span><br><span class="line">    attributes.put(<span class="string">"AutoConfigureAfter"</span>, ValueExtractor.allFrom(<span class="string">"value"</span>, <span class="string">"name"</span>));</span><br><span class="line">    attributes.put(<span class="string">"AutoConfigureOrder"</span>, ValueExtractor.allFrom(<span class="string">"value"</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><validateCode>properties</validateCode> 属性，扫描和处理注解（Annotation），生成的 Properties 对象。</li>
</ul>
<h2 id="3-2-ValueExtractor"><a href="#3-2-ValueExtractor" class="headerlink" title="3.2 ValueExtractor"></a>3.2 ValueExtractor</h2><p>ValueExtractor ，是 AutoConfigureAnnotationProcessor 的内部接口，值提取器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor#ValueExtractor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValueExtractor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从注解中，获得对应的值的数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotation 注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Object&gt; <span class="title">getValues</span><span class="params">(AnnotationMirror annotation)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 NamedValuesExtractor 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> names 从注解的指定 names 中，提取值们</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> NamedValuesExtractor 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ValueExtractor <span class="title">allFrom</span><span class="params">(String... names)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NamedValuesExtractor(names);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-1-AbstractValueExtractor"><a href="#3-2-1-AbstractValueExtractor" class="headerlink" title="3.2.1 AbstractValueExtractor"></a>3.2.1 AbstractValueExtractor</h3><p>AbstractValueExtractor ，是 AutoConfigureAnnotationProcessor 的内部类，实现 ValueExtractor 接口，ValueExtractor 抽象实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor#AbstractValueExtractor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractValueExtractor</span> <span class="keyword">implements</span> <span class="title">ValueExtractor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Stream&lt;Object&gt; <span class="title">extractValues</span><span class="params">(AnnotationValue annotationValue)</span> </span>{</span><br><span class="line">        <span class="comment">// 注解值为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (annotationValue == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Stream.empty();</span><br><span class="line">        }</span><br><span class="line">        Object value = annotationValue.getValue();</span><br><span class="line">        <span class="comment">// 注解值为数组，则遍历数组，逐个提取值</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> List) {</span><br><span class="line">            <span class="keyword">return</span> ((List&lt;AnnotationValue&gt;) value).stream()</span><br><span class="line">                    .map((annotation) -&gt; extractValue(annotation.getValue()));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 注解值非数组，直接提取值</span></span><br><span class="line">        <span class="keyword">return</span> Stream.of(extractValue(value));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">extractValue</span><span class="params">(Object value)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> DeclaredType) {</span><br><span class="line">            <span class="keyword">return</span> Elements.getQualifiedName(((DeclaredType) value).asElement());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>提供了从 AnnotationValue 读取值的公用方法。</li>
</ul>
<h3 id="3-2-2-NamedValuesExtractor"><a href="#3-2-2-NamedValuesExtractor" class="headerlink" title="3.2.2 NamedValuesExtractor"></a>3.2.2 NamedValuesExtractor</h3><p>NamedValuesExtractor ，是 AutoConfigureAnnotationProcessor 的内部类，继承 AbstractValueExtractor 抽象类，读取 <validateCode>names</validateCode> 的 ValueExtractor 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor#NamedValuesExtractor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedValuesExtractor</span> <span class="keyword">extends</span> <span class="title">AbstractValueExtractor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; names;</span><br><span class="line"></span><br><span class="line">    NamedValuesExtractor(String... names) {</span><br><span class="line">        <span class="keyword">this</span>.names = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(names));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getValues</span><span class="params">(AnnotationMirror annotation)</span> </span>{</span><br><span class="line">        List&lt;Object&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历 names 数组，读取 name 对应的值，添加到 result 中</span></span><br><span class="line">        annotation.getElementValues().forEach((key, value) -&gt; {</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.names.contains(key.getSimpleName().toString())) {</span><br><span class="line">                extractValues(value).forEach(result::add);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-3-OnBeanConditionValueExtractor"><a href="#3-2-3-OnBeanConditionValueExtractor" class="headerlink" title="3.2.3 OnBeanConditionValueExtractor"></a>3.2.3 OnBeanConditionValueExtractor</h3><p>OnBeanConditionValueExtractor ，是 AutoConfigureAnnotationProcessor 的内部类，继承 AbstractValueExtractor 抽象类，读取 <validateCode>@ConditionalOnBean</validateCode> 和 <validateCode>@ConditionalOnSingleCandidate</validateCode> 注解的 ValueExtractor 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor#OnBeanConditionValueExtractor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnBeanConditionValueExtractor</span> <span class="keyword">extends</span> <span class="title">AbstractValueExtractor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getValues</span><span class="params">(AnnotationMirror annotation)</span> </span>{</span><br><span class="line">        <span class="comment">// 遍历注解的元素们，读取到 attributes 中</span></span><br><span class="line">        Map&lt;String, AnnotationValue&gt; attributes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        annotation.getElementValues().forEach((key, value) -&gt; attributes.put(key.getSimpleName().toString(), value));</span><br><span class="line">        <span class="comment">// 如果 "name" 对应的值为空，返回空</span></span><br><span class="line">        <span class="keyword">if</span> (attributes.containsKey(<span class="string">"name"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 读取 "value"、`"type"` 对应的值，添加到 result 中</span></span><br><span class="line">        List&lt;Object&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        extractValues(attributes.get(<span class="string">"value"</span>)).forEach(result::add);</span><br><span class="line">        extractValues(attributes.get(<span class="string">"type"</span>)).forEach(result::add);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-2-4-OnClassConditionValueExtractor"><a href="#3-2-4-OnClassConditionValueExtractor" class="headerlink" title="3.2.4 OnClassConditionValueExtractor"></a>3.2.4 OnClassConditionValueExtractor</h3><p>OnClassConditionValueExtractor ，是 AutoConfigureAnnotationProcessor 的内部类，继承 NamedValuesExtractor 类，读取  <validateCode>@OnClassConditionValueExtractor</validateCode> 注解的 ValueExtractor 实现类。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor#OnClassConditionValueExtractor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OnClassConditionValueExtractor</span> <span class="keyword">extends</span> <span class="title">NamedValuesExtractor</span> </span>{</span><br><span class="line"></span><br><span class="line">    OnClassConditionValueExtractor() {</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"value"</span>, <span class="string">"name"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">getValues</span><span class="params">(AnnotationMirror annotation)</span> </span>{</span><br><span class="line">        <span class="comment">// 读取 "value", "name" 的值</span></span><br><span class="line">        List&lt;Object&gt; values = <span class="keyword">super</span>.getValues(annotation);</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        values.sort(<span class="keyword">this</span>::compare);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Comparator.comparing(<span class="keyword">this</span>::isSpringClass)</span><br><span class="line">                .thenComparing(String.CASE_INSENSITIVE_ORDER)</span><br><span class="line">                .compare(o1.toString(), o2.toString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSpringClass</span><span class="params">(String type)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> type.startsWith(<span class="string">"org.springframework"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="3-3-process"><a href="#3-3-process" class="headerlink" title="3.3 process"></a>3.3 process</h2><p>实现 <validateCode>#process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</validateCode> 方法，进行处理。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 遍历 annotations 集合，逐个处理</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : <span class="keyword">this</span>.annotations.entrySet()) {</span><br><span class="line">		process(roundEnv, entry.getKey(), entry.getValue());</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// &lt;2&gt; 处理完成，写到文件 PROPERTIES_PATH 中</span></span><br><span class="line">	<span class="keyword">if</span> (roundEnv.processingOver()) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			writeProperties();</span><br><span class="line">		} <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to write metadata"</span>, ex);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#process(RoundEnvironment roundEnv, String propertyKey, String annotationName)</validateCode> 方法，遍历 <validateCode>annotations</validateCode> 集合，逐个处理，添加到 <validateCode>properties</validateCode> 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(RoundEnvironment roundEnv, String propertyKey, String annotationName)</span> </span>{</span><br><span class="line">    TypeElement annotationType = <span class="keyword">this</span>.processingEnv.getElementUtils().getTypeElement(annotationName);</span><br><span class="line">    <span class="keyword">if</span> (annotationType != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (Element element : roundEnv.getElementsAnnotatedWith(annotationType)) {</span><br><span class="line">            Element enclosingElement = element.getEnclosingElement();</span><br><span class="line">            <span class="keyword">if</span> (enclosingElement != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; enclosingElement.getKind() == ElementKind.PACKAGE) {</span><br><span class="line">                processElement(element, propertyKey, annotationName);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// propertyKey=注解名</span></span><br><span class="line"><span class="comment">// annotationName=全类名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Element element, String propertyKey, String annotationName)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 获得自动配置类的全类名。例如说：org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</span></span><br><span class="line">        String qualifiedName = Elements.getQualifiedName(element);</span><br><span class="line">        <span class="comment">// 获得 AnnotationMirror 对象</span></span><br><span class="line">        AnnotationMirror annotation = getAnnotation(element, annotationName);</span><br><span class="line">        <span class="keyword">if</span> (qualifiedName != <span class="keyword">null</span> &amp;&amp; annotation != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 获得值</span></span><br><span class="line">            List&lt;Object&gt; values = getValues(propertyKey, annotation);</span><br><span class="line">            <span class="comment">// 添加到 properties 中</span></span><br><span class="line">            <span class="keyword">this</span>.properties.put(qualifiedName + <span class="string">"."</span> + propertyKey, toCommaDelimitedString(values));</span><br><span class="line">            <span class="comment">// 添加到 properties 中</span></span><br><span class="line">            <span class="keyword">this</span>.properties.put(qualifiedName, <span class="string">""</span>);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error processing configuration meta-data on "</span> + element, ex);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 AnnotationMirror 对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> AnnotationMirror <span class="title">getAnnotation</span><span class="params">(Element element, String type)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (element != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (AnnotationMirror annotation : element.getAnnotationMirrors()) {</span><br><span class="line">            <span class="keyword">if</span> (type.equals(annotation.getAnnotationType().toString())) {</span><br><span class="line">                <span class="keyword">return</span> annotation;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Object&gt; <span class="title">getValues</span><span class="params">(String propertyKey, AnnotationMirror annotation)</span> </span>{</span><br><span class="line">    ValueExtractor extractor = <span class="keyword">this</span>.valueExtractors.get(propertyKey);</span><br><span class="line">    <span class="keyword">if</span> (extractor == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> extractor.getValues(annotation);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">toCommaDelimitedString</span><span class="params">(List&lt;Object&gt; list)</span> </span>{</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (Object item : list) {</span><br><span class="line">        result.append((result.length() != <span class="number">0</span>) ? <span class="string">","</span> : <span class="string">""</span>);</span><br><span class="line">        result.append(item);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>胖友简单瞅两眼即可，不是很重要哈~</li>
</ul>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#writeProperties()</validateCode> 方法，处理完成，写到文件 <validateCode>PROPERTIES_PATH</validateCode> 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AutoConfigureAnnotationProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPERTIES_PATH = <span class="string">"META-INF/"</span> + <span class="string">"spring-autoconfigure-metadata.properties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.properties.isEmpty()) {</span><br><span class="line">        <span class="comment">// 创建 FileObject 对象</span></span><br><span class="line">        FileObject file = <span class="keyword">this</span>.processingEnv.getFiler().createResource(StandardLocation.CLASS_OUTPUT, <span class="string">""</span>, PROPERTIES_PATH);</span><br><span class="line">        <span class="comment">// 写入 properties 到文件</span></span><br><span class="line">        <span class="keyword">try</span> (OutputStream outputStream = file.openOutputStream()) {</span><br><span class="line">            <span class="keyword">this</span>.properties.store(outputStream, <span class="keyword">null</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这不，和 <a href="#">「2. AutoConfigurationMetadataLoader」</a> 就对上列。</li>
</ul>
</li>
</ul>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>😈 简单小文一篇~在 <validateCode>spring-boot-autoconfigure-processor</validateCode> 的寻找上，花了一些些时间。HOHO ~</p>




</div>