<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来补充 <a href="http://svip.iocoder.cn/Spring-Boot/SpringApplication">《精尽 Spring Boot 源码分析 —— SpringApplication》</a> 文章，并未详细解析的 ApplicationListener 。</p>
<h1 id="2-ApplicationListener"><a href="#2-ApplicationListener" class="headerlink" title="2. ApplicationListener"></a>2. ApplicationListener</h1><p><validateCode>org.springframework.context.ApplicationListener</validateCode> ，应用事件监听器接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface to be implemented by application event listeners.</span></span><br><span class="line"><span class="comment"> * Based on the standard {<span class="doctag">@validateCode</span> java.util.EventListener} interface</span></span><br><span class="line"><span class="comment"> * for the Observer design pattern.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring 3.0, an ApplicationListener can generically declare the event type</span></span><br><span class="line"><span class="comment"> * that it is interested in. When registered with a Spring ApplicationContext, events</span></span><br><span class="line"><span class="comment"> * will be filtered accordingly, with the listener getting invoked for matching event</span></span><br><span class="line"><span class="comment"> * objects only.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rod Johnson</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt; the specific ApplicationEvent subclass to listen to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.context.event.ApplicationEventMulticaster</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationListener</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title">EventListener</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Handle an application event.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> event the event to respond to</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(E event)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>如果对这块不了解的胖友，可以看看 <a href="http://www.iocoder.cn/Spring/ApplicationContextEvent/?vip" rel="external nofollow noopener noreferrer" target="_blank">《Spring 5 源码解析 —— Spring 框架中的事件和监听器》</a> 文章。</li>
</ul>
<h2 id="2-1-SmartApplicationListener"><a href="#2-1-SmartApplicationListener" class="headerlink" title="2.1 SmartApplicationListener"></a>2.1 SmartApplicationListener</h2><p><validateCode>org.springframework.context.event.SmartApplicationListener</validateCode> 接口，实现 ApplicationListener、Ordered 接口，是 Spring3.0 新增的接口，提供了事件类型和来源的判断接口方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SmartApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extended variant of the standard {<span class="doctag">@link</span> ApplicationListener} interface,</span></span><br><span class="line"><span class="comment"> * exposing further metadata such as the supported event and source type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For full introspection of generic event types, consider implementing</span></span><br><span class="line"><span class="comment"> * the {<span class="doctag">@link</span> GenericApplicationListener} interface instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Juergen Hoeller</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericApplicationListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericApplicationListenerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartApplicationListener</span> <span class="keyword">extends</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt;, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事件类型</span></span><br><span class="line"><span class="comment">	 * Determine whether this listener actually supports the given event type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> eventType the event type (never {<span class="doctag">@validateCode</span> null})</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事件来源</span></span><br><span class="line"><span class="comment">	 * Determine whether this listener actually supports the given source type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation always returns {<span class="doctag">@validateCode</span> true}.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sourceType the source type, or {<span class="doctag">@validateCode</span> null} if no source</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(@Nullable Class&lt;?&gt; sourceType)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine this listener's order in a set of listeners for the same event.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns {<span class="doctag">@link</span> #LOWEST_PRECEDENCE}.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> LOWEST_PRECEDENCE;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="2-1-GenericApplicationListener"><a href="#2-1-GenericApplicationListener" class="headerlink" title="2.1 GenericApplicationListener"></a>2.1 GenericApplicationListener</h2><p><validateCode>org.springframework.context.event.GenericApplicationListener</validateCode> ，继承 ApplicationListener、Ordered 接口，是 Spring4.2 新增的接口，它增强了对泛型的支持，<validateCode>#supportsEventType(ResolvableType)</validateCode> 方法的参数采用的是可解析类型 ResolvableType 。代码如下：</p>
<blockquote>
<p>ResolvableType是 Spring4 提供的泛型操作支持类，通过它可以很容易地获得泛型的实际类型信息，比如类级、字段级等等泛型信息。在 Spring4 的框架中，很多核心类内部涉及的泛型操作大都使用 ResolvableType 类进行处理。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// GenericApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Extended variant of the standard {<span class="doctag">@link</span> ApplicationListener} interface,</span></span><br><span class="line"><span class="comment"> * exposing further metadata such as the supported event and source type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;As of Spring Framework 4.2, this interface supersedes the Class-based</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> SmartApplicationListener} with full handling of generic event types.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephane Nicoll</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> SmartApplicationListener</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> GenericApplicationListenerAdapter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericApplicationListener</span> <span class="keyword">extends</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt;, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事件类型【有变动】</span></span><br><span class="line"><span class="comment">	 * Determine whether this listener actually supports the given event type.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> eventType the event type (never {<span class="doctag">@validateCode</span> null})</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType eventType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 事件来源</span></span><br><span class="line"><span class="comment">	 * Determine whether this listener actually supports the given source type.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation always returns {<span class="doctag">@validateCode</span> true}.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> sourceType the source type, or {<span class="doctag">@validateCode</span> null} if no source</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(@Nullable Class&lt;?&gt; sourceType)</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Determine this listener's order in a set of listeners for the same event.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns {<span class="doctag">@link</span> #LOWEST_PRECEDENCE}.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> LOWEST_PRECEDENCE;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-SpringApplication-中的使用"><a href="#3-SpringApplication-中的使用" class="headerlink" title="3. SpringApplication 中的使用"></a>3. SpringApplication 中的使用</h1><p>在 SpringApplication 构造方法中，会调用 <validateCode>#getSpringFactoriesInstances(Class&lt;T&gt; type)</validateCode> 方法，获得 ApplicationListener 集合。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] {});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>{</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 加载指定类型对应的，在 `META-INF/spring.factories` 里的类名的数组</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// &lt;2&gt; 创建对象们</span></span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 排序对象们</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，加载指定 ApplicationListener 类型对应的，在 <validateCode>META-INF/spring.factories</validateCode> 里的类名的数组。<ul>
<li>假设只在 Spring MVC 的环境下，<validateCode>listeners</validateCode> 属性的结果如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-07/02.jpg" alt="`listeners` 属性"></li>
<li>艿艿整理了 Spring Boot 中，ApplicationContextInitializer 的实现类们，非常多。本文，我们就分享上述的 10 个。</li>
</ul>
</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，创建对象们。</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，排序对象们。</li>
</ul>
<h1 id="4-ConfigFileApplicationListener"><a href="#4-ConfigFileApplicationListener" class="headerlink" title="4. ConfigFileApplicationListener"></a>4. ConfigFileApplicationListener</h1><p><validateCode>org.springframework.boot.context.config.ConfigFileApplicationListener</validateCode> ，实现 SmartApplicationListener、Ordered、EnvironmentPostProcessor 接口，实现 Spring Boot 配置文件的加载。</p>
<p>考虑到它非常重要，且复杂，我们单独在 <a href="http://svip.iocoder.cn/Spring-Boot/properties-load">《精尽 Spring Boot 源码分析 —— 配置加载》</a> 详细解析。</p>
<h1 id="5-AnsiOutputApplicationListener"><a href="#5-AnsiOutputApplicationListener" class="headerlink" title="5. AnsiOutputApplicationListener"></a>5. AnsiOutputApplicationListener</h1><p><validateCode>org.springframework.boot.context.config.AnsiOutputApplicationListener</validateCode> ，实现 ApplicationListener、Ordered 接口，在 Spring Boot 环境变量(<validateCode>environment</validateCode>)准备完成以后运行，<br>如果你的终端支持 ANSI ，设置彩色输出会让日志更具可读性。</p>
<blockquote>
<p>不了解“彩色输出”的胖友，可以看看 <a href="http://blog.didispace.com/springbootlog/" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot日志管理》</a> 文章。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigFileApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnsiOutputApplicationListener</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEnvironmentPreparedEvent</span>&gt;, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>{ <span class="comment">// &lt;1&gt;</span></span><br><span class="line"><span class="comment">//	    if (true) { </span></span><br><span class="line"><span class="comment">//	        return; // &lt;X&gt;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">		ConfigurableEnvironment environment = event.getEnvironment();</span><br><span class="line">		<span class="comment">// &lt;2&gt; 根据环境变量 spring.output.ansi.enabled 的值，设置 AnsiOutput.enabled 属性</span></span><br><span class="line">		Binder.get(environment).bind(<span class="string">"spring.output.ansi.enabled"</span>, AnsiOutput.Enabled.class)</span><br><span class="line">                .ifBound(AnsiOutput::setEnabled);</span><br><span class="line">		<span class="comment">// &lt;3&gt; 根据环境变量 "spring.output.ansi.console-available 的值，设置 AnsiOutput.consoleAvailable 属性</span></span><br><span class="line">		AnsiOutput.setConsoleAvailable(environment.getProperty(<span class="string">"spring.output.ansi.console-available"</span>, Boolean.class));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="comment">// Apply after ConfigFileApplicationListener has called EnvironmentPostProcessors</span></span><br><span class="line">		<span class="keyword">return</span> ConfigFileApplicationListener.DEFAULT_ORDER + <span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，我们可以知道，监听的是 ApplicationEnvironmentPreparedEvent 事件。</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，根据环境变量 <validateCode>"spring.output.ansi.enabled"</validateCode> 的值，设置 <validateCode>AnsiOutput.enabled</validateCode> 属性。这块的逻辑，卡了艿艿很久，一点一点来说。</p>
<ul>
<li><p>首先，因为艿艿并没有细看 Binder 的实现代码，所以这块就卡了一会。简单来说，<validateCode>Binder.get(environment).bind("spring.output.ansi.enabled", AnsiOutput.Enabled.class)</validateCode> 代码块的意思是，从 <validateCode>environment</validateCode> 读取 <validateCode>"spring.output.ansi.enabled"</validateCode> 对应的值，并转换成 AnsiOutput.Enabled 类型。其中，AnsiOutput.Enabled 的枚举值如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// AnsiOutput#Enabled.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Enabled {</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动探测，根据是否支持 ANSI 的功能，来判断是否要彩色输出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 【默认值】</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">	 * Try to detect whether ANSI coloring capabilities are available. The default</span></span><br><span class="line"><span class="comment">	 * value for {<span class="doctag">@link</span> AnsiOutput}.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	DETECT,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总是开启 ANSI 彩色输出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">	 * Enable ANSI-colored output.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ALWAYS,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 禁用 ANSI 彩色输出</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">	 * Disable ANSI-colored output.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	NEVER</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>貌似也没什么问题。但是，让艿艿闷逼的是，为什么结果会是 <validateCode>AnsiOutput.Enabled.ALWAYS</validateCode> ，在 IDEA 环境中。后来，在 <validateCode>environment</validateCode> 中，一个名字是 <validateCode>"systemProperties"</validateCode> 的 MapPropertySource 属性源，里面提供了 <validateCode>"spring.output.ansi.enabled=always"</validateCode> 的配置。</p>
<ul>
<li>各种全文检索代码，貌似除了测试用例里，没有地方强制赋值了 <validateCode>"spring.output.ansi.enabled"</validateCode> 。</li>
<li>后来发现，<validateCode>"systemProperties"</validateCode> 这个 MapPropertySource 属性源，读取的是 <validateCode>System#getProperties()</validateCode> 方法，但是为啥里面会有 <validateCode>"spring.output.ansi.enabled=always"</validateCode> 呢？目前的猜测是，IDEA 判断在 Spring Boot 环境下，自动添加进去的！<ul>
<li>然后，<validateCode>.ifBound(AnsiOutput::setEnabled)</validateCode> 代码段，应该翻译成如下的代码，可能比较易懂：<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line">Binder.get(environment).bind(<span class="string">"spring.output.ansi.enabled"</span>, AnsiOutput.Enabled.class)</span><br><span class="line">.ifBound(<span class="keyword">new</span> Consumer&lt;Enabled&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Enabled enabled)</span> </span>{</span><br><span class="line">        AnsiOutput.setEnabled(enabled);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>即，<validateCode>Binder.get(environment).bind("spring.output.ansi.enabled", AnsiOutput.Enabled.class)</validateCode> 返回的是 BindResult 对象，然后调用 <validateCode>BindResult#ifBound(Consumer)</validateCode> 方法，将解析到的属性值，赋值到 <validateCode>AnsiOutput.enabled</validateCode> 属性。</p>
<ul>
<li>😈 真的是有点绕噢。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><validateCode>&lt;3&gt;</validateCode> 处，根据环境变量 <validateCode>"spring.output.ansi.console-available"</validateCode> 的值，设置 <validateCode>AnsiOutput.consoleAvailable</validateCode> 属性。</p>
</li>
</ul>
<p>通过这样的方式，后续在 IDEA 中，我们就可以发现日志打印出来的，是带有彩色输出的。如果胖友是个调皮的人，可以尝试打开 <validateCode>&lt;X&gt;</validateCode> 处的三行注释，然后重新运行，就神奇的发现，彩色输出不见了，嘿嘿嘿。</p>
<h1 id="6-LoggingApplicationListener"><a href="#6-LoggingApplicationListener" class="headerlink" title="6. LoggingApplicationListener"></a>6. LoggingApplicationListener</h1><p><validateCode>org.springframework.boot.context.logging.LoggingApplicationListener</validateCode> ，实现 GenericApplicationListener 接口，实现根据配置初始化日志系统 Logger 。</p>
<p>考虑到它非常重要，且复杂，我们单独在 <a href="http://svip.iocoder.cn/Spring-Boot/logger-system">《精尽 Spring Boot 源码分析 —— 日志系统》</a> 详细解析。</p>
<h1 id="7-ClasspathLoggingApplicationListener"><a href="#7-ClasspathLoggingApplicationListener" class="headerlink" title="7. ClasspathLoggingApplicationListener"></a>7. ClasspathLoggingApplicationListener</h1><p><validateCode>org.springframework.boot.context.logging.ClasspathLoggingApplicationListener</validateCode> ，实现 GenericApplicationListener 接口，程序启动时，将 classpath 打印到 debug 日志，启动失败时 classpath 打印到 debug 日志。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ClasspathLoggingApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClasspathLoggingApplicationListener</span> <span class="keyword">implements</span> <span class="title">GenericApplicationListener</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ORDER = LoggingApplicationListener.DEFAULT_ORDER + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(ClasspathLoggingApplicationListener.class);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) {</span><br><span class="line">		    <span class="comment">// 如果是 ApplicationEnvironmentPreparedEvent 事件，说明启动成功，打印成功到 debug 日志中</span></span><br><span class="line">			<span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) {</span><br><span class="line">				logger.debug(<span class="string">"Application started with classpath: "</span> + getClasspath());</span><br><span class="line">            <span class="comment">// 如果是 ApplicationFailedEvent 事件，说明启动失败，打印失败到 debug 日志中</span></span><br><span class="line">			} <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationFailedEvent) {</span><br><span class="line">				logger.debug(<span class="string">"Application failed to start with classpath: "</span> + getClasspath());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> ORDER;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType resolvableType)</span> </span>{</span><br><span class="line">		Class&lt;?&gt; type = resolvableType.getRawClass(); <span class="comment">// 使用 ResolvableType 类，可以解析当前传入的参数的泛型，从而后的事件类型</span></span><br><span class="line">		<span class="keyword">if</span> (type == <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 判断是否需为 ApplicationEnvironmentPreparedEvent 或者 ApplicationFailedEvent 事件</span></span><br><span class="line">		<span class="keyword">return</span> ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(type)</span><br><span class="line">				|| ApplicationFailedEvent.class.isAssignableFrom(type);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 获得 classpath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getClasspath</span><span class="params">()</span> </span>{</span><br><span class="line">		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">		<span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> URLClassLoader) {</span><br><span class="line">			<span class="keyword">return</span> Arrays.toString(((URLClassLoader) classLoader).getURLs());</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="8-BackgroundPreinitializer"><a href="#8-BackgroundPreinitializer" class="headerlink" title="8. BackgroundPreinitializer"></a>8. BackgroundPreinitializer</h1><p><validateCode>org.springframework.boot.autoconfigure.BackgroundPreinitializer</validateCode> ，实现 ApplicationListener 接口，实现后台提前执行耗时的初始化任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// BackgroundPreinitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Order</span>(LoggingApplicationListener.DEFAULT_ORDER + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPreinitializer</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">SpringApplicationEvent</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * System property that instructs Spring Boot how to run pre initialization. When the</span></span><br><span class="line"><span class="comment">     * property is set to {<span class="doctag">@validateCode</span> true}, no pre-initialization happens and each item is</span></span><br><span class="line"><span class="comment">     * initialized in the foreground as it needs to. When the property is {<span class="doctag">@validateCode</span> false}</span></span><br><span class="line"><span class="comment">     * (default), pre initialization runs in a separate thread in the background.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IGNORE_BACKGROUNDPREINITIALIZER_PROPERTY_NAME = <span class="string">"spring.backgroundpreinitializer.ignore"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预初始化任务是否已启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicBoolean preinitializationStarted = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预初始化任务的 CountDownLatch 对象，用于实现等待预初始化任务是否完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch preinitializationComplete = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(SpringApplicationEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// &lt;1&gt; 如果是开启后台预初始化任务，默认情况下开启</span></span><br><span class="line">        <span class="comment">// 并且，是 ApplicationStartingEvent 事件，说明应用正在启动中</span></span><br><span class="line">        <span class="comment">// 并且，是多核环境</span></span><br><span class="line">        <span class="comment">// 并且，预初始化任务未启动</span></span><br><span class="line">        <span class="keyword">if</span> (!Boolean.getBoolean(IGNORE_BACKGROUNDPREINITIALIZER_PROPERTY_NAME)</span><br><span class="line">                &amp;&amp; event <span class="keyword">instanceof</span> ApplicationStartingEvent</span><br><span class="line">                &amp;&amp; multipleProcessors()</span><br><span class="line">                &amp;&amp; preinitializationStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            performPreinitialization();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// &lt;2&gt; 如果是 ApplicationReadyEvent 或 ApplicationFailedEvent 事件，说明应用启动成功后失败，则等待预初始化任务完成</span></span><br><span class="line">        <span class="keyword">if</span> ((event <span class="keyword">instanceof</span> ApplicationReadyEvent</span><br><span class="line">                || event <span class="keyword">instanceof</span> ApplicationFailedEvent)</span><br><span class="line">                &amp;&amp; preinitializationStarted.get()) { <span class="comment">// 判断预初始化任务已经启动</span></span><br><span class="line">            <span class="comment">// 通过 CountDownLatch 实现，预初始化任务执行完成。</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                preinitializationComplete.await();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException ex) {</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 判断是否多核环境</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">multipleProcessors</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Runtime.getRuntime().availableProcessors() &gt; <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>几个变量，胖友直接看代码注释。</li>
<li><validateCode>&lt;1&gt;</validateCode> 处，满足如下的四个条件（每一行注释，对应一个条件），调用 <validateCode>#performPreinitialization()</validateCode> 方法，启动线程，后台执行预初始化任务。关于 <validateCode>#performPreinitialization()</validateCode> 方法，在 <a href="#">「8.1 performPreinitialization」</a> 详细解析。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，如果是 ApplicationReadyEvent 或 ApplicationFailedEvent 事件，说明应用启动成功后失败，则等待预初始化任务完成。</li>
<li>总结来说，<validateCode>&lt;1&gt;</validateCode> 处，启动后台任务，<validateCode>&lt;2&gt;</validateCode> 处，保证后台任务执行完成。</li>
</ul>
<h2 id="8-1-performPreinitialization"><a href="#8-1-performPreinitialization" class="headerlink" title="8.1 performPreinitialization"></a>8.1 performPreinitialization</h2><p><validateCode>#performPreinitialization()</validateCode> 方法，启动线程，后台执行预初始化任务。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// BackgroundPreinitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPreinitialization</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// &lt;1&gt; 创建线程</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">// 安全运行每个初始化任务</span></span><br><span class="line">                runSafely(<span class="keyword">new</span> ConversionServiceInitializer());</span><br><span class="line">                runSafely(<span class="keyword">new</span> ValidationInitializer());</span><br><span class="line">                runSafely(<span class="keyword">new</span> MessageConverterInitializer());</span><br><span class="line">                runSafely(<span class="keyword">new</span> MBeanFactoryInitializer());</span><br><span class="line">                runSafely(<span class="keyword">new</span> JacksonInitializer());</span><br><span class="line">                runSafely(<span class="keyword">new</span> CharsetInitializer());</span><br><span class="line">                <span class="comment">// &lt;3&gt; 标记 preinitializationComplete 完成</span></span><br><span class="line">                preinitializationComplete.countDown();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runSafely</span><span class="params">(Runnable runnable)</span> </span>{</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    runnable.run();</span><br><span class="line">                } <span class="keyword">catch</span> (Throwable ex) {</span><br><span class="line">                    <span class="comment">// Ignore</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }, <span class="string">"background-preinit"</span>);</span><br><span class="line">        <span class="comment">// &lt;2&gt; 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">        <span class="comment">// This will fail on GAE where creating threads is prohibited. We can safely</span></span><br><span class="line">        <span class="comment">// continue but startup will be slightly slower as the initialization will now</span></span><br><span class="line">        <span class="comment">// happen on the main thread.</span></span><br><span class="line">        <span class="comment">// 标记 preinitializationComplete 完成</span></span><br><span class="line">        preinitializationComplete.countDown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，创建一个线程，用于后台调用 <validateCode>#runSafely(Runnable runnable)</validateCode> 方法，“安全”（即发生异常，不进行抛出去）执行每个初始化任务。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，启动线程。</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，在所有初始化任务都执行完成后，通过标记 <validateCode>preinitializationComplete</validateCode> 完成，从而实现在 <validateCode>#onApplicationEvent(SpringApplicationEvent even)</validateCode> 的 <validateCode>&lt;2&gt;</validateCode> 处的阻塞等待被通知完成。</li>
</ul>
<h2 id="8-2-初始化任务"><a href="#8-2-初始化任务" class="headerlink" title="8.2 初始化任务"></a>8.2 初始化任务</h2><ul>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L180" rel="external nofollow noopener noreferrer" target="_blank">ConversionServiceInitializer</a></li>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L155" rel="external nofollow noopener noreferrer" target="_blank">ValidationInitializer</a></li>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L131" rel="external nofollow noopener noreferrer" target="_blank">MessageConverterInitializer</a></li>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L143" rel="external nofollow noopener noreferrer" target="_blank">MBeanFactoryInitializer</a></li>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L168" rel="external nofollow noopener noreferrer" target="_blank">JacksonInitializer</a></li>
<li><a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/BackgroundPreinitializer.java#L189" rel="external nofollow noopener noreferrer" target="_blank">CharsetInitializer</a></li>
</ul>
<h1 id="9-DelegatingApplicationListener"><a href="#9-DelegatingApplicationListener" class="headerlink" title="9. DelegatingApplicationListener"></a>9. DelegatingApplicationListener</h1><p><validateCode>org.springframework.boot.context.config.DelegatingApplicationListener</validateCode> ，实现 ApplicationListener、Ordered 接口，和 <a href="http://svip.iocoder.cn/Spring-Boot/ApplicationContextInitializer">「DelegatingApplicationContextInitializer」</a> 是类似的，只是读取的是环境变量 <validateCode>"context.listener.classes"</validateCode> 对应的 ApplicationContextInitializer 实现类们。</p>
<h1 id="10-ParentContextCloserApplicationListener"><a href="#10-ParentContextCloserApplicationListener" class="headerlink" title="10. ParentContextCloserApplicationListener"></a>10. ParentContextCloserApplicationListener</h1><p><validateCode>org.springframework.boot.builder.ParentContextCloserApplicationListener</validateCode> ，实现 ApplicationListener、ApplicationContextAware、Ordered 接口，容器关闭时发出通知，如果父容器关闭，那么自容器也一起关闭。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ParentContextCloserApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentContextCloserApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ParentContextAvailableEvent</span>&gt;, <span class="title">ApplicationContextAware</span>, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顺序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> order = Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext context)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">		<span class="keyword">this</span>.context = context;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ParentContextAvailableEvent event)</span> </span>{</span><br><span class="line">		maybeInstallListenerInParent(event.getApplicationContext()); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ... 省略其它方法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在 <validateCode>&lt;1&gt;</validateCode> 处，我们可以看到当接收到 ParentContextAvailableEvent 事件后，会调用 <validateCode>#maybeInstallListenerInParent(ConfigurableApplicationContext child)</validateCode> 方法，向父容器添加监听器，监听父容器的关闭事件。详细解析，见 <a href="#">「10.1 maybeInstallListenerInParent」</a> 。</li>
<li>ParentContextAvailableEvent 事件的发布，依赖 <a href="https://github.com/YunaiV/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/builder/ParentContextApplicationContextInitializer.java" rel="external nofollow noopener noreferrer" target="_blank"><validateCode>org.springframework.boot.builder.ParentContextApplicationContextInitializer</validateCode></a> 初始化类。默认情况下，ParentContextApplicationContextInitializer 类并未使用，所以吧，😈 ParentContextCloserApplicationListener 基本无法生效列。</li>
</ul>
<h2 id="10-1-maybeInstallListenerInParent"><a href="#10-1-maybeInstallListenerInParent" class="headerlink" title="10.1 maybeInstallListenerInParent"></a>10.1 maybeInstallListenerInParent</h2><p><validateCode>#maybeInstallListenerInParent(ConfigurableApplicationContext child)</validateCode> 方法，向父容器添加监听器，监听父容器的关闭事件。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ParentContextCloserApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeInstallListenerInParent</span><span class="params">(ConfigurableApplicationContext child)</span> </span>{</span><br><span class="line">    <span class="comment">// 如果 child 是当前容器</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">this</span>.context</span><br><span class="line">            <span class="comment">// 并且父容器是 ConfigurableApplicationContext 类型</span></span><br><span class="line">            &amp;&amp; child.getParent() <span class="keyword">instanceof</span> ConfigurableApplicationContext) {</span><br><span class="line">        <span class="comment">// 向父容器添加监听器，监听父容器的关闭事件</span></span><br><span class="line">        ConfigurableApplicationContext parent = (ConfigurableApplicationContext) child.getParent();</span><br><span class="line">        parent.addApplicationListener(createContextCloserListener(child)); <span class="comment">// &lt;1&gt;</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>在 <validateCode>&lt;1&gt;</validateCode> 处，会调用 <validateCode>#createContextCloserListener(ConfigurableApplicationContext child)</validateCode> 方法，创建 ContextCloserListener 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ParentContextCloserApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ContextCloserListener <span class="title">createContextCloserListener</span><span class="params">(ConfigurableApplicationContext child)</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> ContextCloserListener(child);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>关于 ContextCloserListener 类，在 <a href="#">「10.2 ContextCloserListener」</a> 中，详细解析。</li>
</ul>
</li>
<li><validateCode>&lt;1&gt;</validateCode> 处，创建后的 ContextCloserListener 对象，向父容器 <validateCode>parent</validateCode> 中注册。</li>
</ul>
<h2 id="10-2-ContextCloserListener"><a href="#10-2-ContextCloserListener" class="headerlink" title="10.2 ContextCloserListener"></a>10.2 ContextCloserListener</h2><p>ContextCloserListener ，是 ParentContextCloserApplicationListener 的内部类，实现 ApplicationListener 接口，监听父容器关闭时，关闭自己（容器）。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ParentContextCloserApplicationListener#ContextCloserListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextCloserListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextClosedEvent</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;ConfigurableApplicationContext&gt; childContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextCloserListener</span><span class="params">(ConfigurableApplicationContext childContext)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.childContext = <span class="keyword">new</span> WeakReference&lt;&gt;(childContext);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>{</span><br><span class="line">        ConfigurableApplicationContext context = <span class="keyword">this</span>.childContext.get();</span><br><span class="line">        <span class="keyword">if</span> ((context != <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (event.getApplicationContext() == context.getParent()) <span class="comment">// 如果是父容器</span></span><br><span class="line">                &amp;&amp; context.isActive()) { <span class="comment">// 并且当前容器是启动状态</span></span><br><span class="line">            <span class="comment">// 关闭当前容器</span></span><br><span class="line">            context.close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="11-ClearCachesApplicationListener"><a href="#11-ClearCachesApplicationListener" class="headerlink" title="11. ClearCachesApplicationListener"></a>11. ClearCachesApplicationListener</h1><p><validateCode>org.springframework.boot.ClearCachesApplicationListener</validateCode> ，实现 ApplicationListener 接口，实现 ReflectionUtils 的缓存、ClassLoader 的缓存。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ClearCachesApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClearCachesApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// 清空 ReflectionUtils 缓存</span></span><br><span class="line">        ReflectionUtils.clearCache();</span><br><span class="line">        <span class="comment">// 清空类加载器的缓存</span></span><br><span class="line">        clearClassLoaderCaches(Thread.currentThread().getContextClassLoader());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearClassLoaderCaches</span><span class="params">(ClassLoader classLoader)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 同构反射调用 ClassLoader 类的 clearCache 方法，清空它的缓存</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Method clearCacheMethod = classLoader.getClass().getDeclaredMethod(<span class="string">"clearCache"</span>);</span><br><span class="line">            clearCacheMethod.invoke(classLoader);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 如果有父加载器，则父加载器清空缓存</span></span><br><span class="line">        clearClassLoaderCaches(classLoader.getParent());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在接收到容器初始化 ContextRefreshedEvent 事件，触发 ClearCachesApplicationListener 监听器，进行清空缓存。</li>
</ul>
<h1 id="12-FileEncodingApplicationListener"><a href="#12-FileEncodingApplicationListener" class="headerlink" title="12. FileEncodingApplicationListener"></a>12. FileEncodingApplicationListener</h1><p><validateCode>org.springframework.boot.context.FileEncodingApplicationListener</validateCode> ，实现 ApplicationListener、Ordered 接口，在Spring Boot 环境准备完成以后运行，获取环境中的系统环境参数，检测当前系统环境的 <validateCode>file.encoding</validateCode> 和 <validateCode>spring.mandatory-file-encoding</validateCode> 设置的值是否一样，如果不一样则抛出异常；<br>如果不配置 <validateCode>spring.mandatory-file-encoding</validateCode> 则不检查。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// FileEncodingApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileEncodingApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEnvironmentPreparedEvent</span>&gt;, <span class="title">Ordered</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(FileEncodingApplicationListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>{</span><br><span class="line">        ConfigurableEnvironment environment = event.getEnvironment();</span><br><span class="line">        <span class="comment">// 如果未配置，则不进行检查</span></span><br><span class="line">        <span class="keyword">if</span> (!environment.containsProperty(<span class="string">"spring.mandatory-file-encoding"</span>)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 比对系统变量的 `file.encoding` ，和环境变量的 `spring.mandatory-file-encoding` 。</span></span><br><span class="line">        <span class="comment">// 如果不一致，抛出 IllegalStateException 异常</span></span><br><span class="line">        String encoding = System.getProperty(<span class="string">"file.encoding"</span>);</span><br><span class="line">        String desired = environment.getProperty(<span class="string">"spring.mandatory-file-encoding"</span>);</span><br><span class="line">        <span class="keyword">if</span> (encoding != <span class="keyword">null</span> &amp;&amp; !desired.equalsIgnoreCase(encoding)) {</span><br><span class="line">            logger.error(<span class="string">"System property 'file.encoding' is currently '"</span> + encoding</span><br><span class="line">                    + <span class="string">"'. It should be '"</span> + desired</span><br><span class="line">                    + <span class="string">"' (as defined in 'spring.mandatoryFileEncoding')."</span>);</span><br><span class="line">            logger.error(<span class="string">"Environment variable LANG is '"</span> + System.getenv(<span class="string">"LANG"</span>)</span><br><span class="line">                    + <span class="string">"'. You could use a locale setting that matches encoding='"</span></span><br><span class="line">                    + desired + <span class="string">"'."</span>);</span><br><span class="line">            logger.error(<span class="string">"Environment variable LC_ALL is '"</span> + System.getenv(<span class="string">"LC_ALL"</span>)</span><br><span class="line">                    + <span class="string">"'. You could use a locale setting that matches encoding='"</span></span><br><span class="line">                    + desired + <span class="string">"'."</span>);</span><br><span class="line">            <span class="comment">// 抛出 IllegalStateException 异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"The Java Virtual Machine has not been configured to use the "</span></span><br><span class="line">                            + <span class="string">"desired default character encoding ("</span> + desired + <span class="string">")."</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="13-LiquibaseServiceLocatorApplicationListener"><a href="#13-LiquibaseServiceLocatorApplicationListener" class="headerlink" title="13. LiquibaseServiceLocatorApplicationListener"></a>13. LiquibaseServiceLocatorApplicationListener</h1><p><validateCode>org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</validateCode> ，实现 ApplicationListener 接口，初始化 Liquibase 的 ServiceLocator 对象。代码如下：</p>
<blockquote>
<p>如果不了解 Liquibase 的胖友，可以看看 <a href="http://www.iocoder.cn/Spring-Boot/battcn/v2-other-liquibase/?vip" rel="external nofollow noopener noreferrer" target="_blank">《一起来学 SpringBoot 2.x | 第二十四篇：数据库管理与迁移（Liquibase）》</a> 文章。</p>
</blockquote>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// LiquibaseServiceLocatorApplicationListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiquibaseServiceLocatorApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationStartingEvent</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(LiquibaseServiceLocatorApplicationListener.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationStartingEvent event)</span> </span>{</span><br><span class="line">        <span class="comment">// &lt;1&gt; 如果存在 CustomResolverServiceLocator 类</span></span><br><span class="line">        <span class="keyword">if</span> (ClassUtils.isPresent(<span class="string">"liquibase.servicelocator.CustomResolverServiceLocator"</span>,</span><br><span class="line">                event.getSpringApplication().getClassLoader())) {</span><br><span class="line">            <span class="keyword">new</span> LiquibasePresent().replaceServiceLocator();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inner class to prevent class not found issues.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LiquibasePresent</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceServiceLocator</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="comment">// &lt;2&gt; 创建 CustomResolverServiceLocator 对象</span></span><br><span class="line">            CustomResolverServiceLocator customResolverServiceLocator = <span class="keyword">new</span> CustomResolverServiceLocator(<span class="keyword">new</span> SpringPackageScanClassResolver(logger));</span><br><span class="line">            <span class="comment">// 设置 ServiceLocator 的 `instance` 属性</span></span><br><span class="line">            ServiceLocator.setInstance(customResolverServiceLocator);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，判断是否存在 <validateCode>liquibase.servicelocator.CustomResolverServiceLocator</validateCode> 类。通过该判断，可以知道是否引入了 <validateCode>liquibase-core</validateCode> 包，需要使初始化 Liquibase 功能。</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，创建 CustomResolverServiceLocator 对象。当然，如果没有自定义的话，这个对象，返回的就是默认的 Liquibase ServiceLocator 对象。</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，设置到 ServiceLocator 的 <validateCode>instance</validateCode> 属性。</li>
</ul>
<p>当然，以上的逻辑，胖友选择性了解即可。哈哈哈哈~</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>严格来说，本文并没有写太多具体的内容。更多的是，为了后面的内容做一个铺垫，同时也让胖友知道，Spring Boot 默认提供的 ApplicationListener 实现类。</p>
<p>参考和推荐如下文章：</p>
<ul>
<li>oldflame-Jm <a href="https://blog.csdn.net/jamet/article/details/78042486" rel="external nofollow noopener noreferrer" target="_blank">《Spring Boot 源码分析 - ApplicationListener 应用环境（5）》</a></li>
</ul>




</div>