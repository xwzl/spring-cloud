<div class="article-entry" itemprop="articleBody">

<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>本文，我们来补充 <a href="http://svip.iocoder.cn/Spring-Boot/SpringApplication">《精尽 Spring Boot 源码分析 —— SpringApplication》</a> 文章，并未详细解析的 ApplicationContextInitializer 。</p>
<h1 id="2-ApplicationContextInitializer"><a href="#2-ApplicationContextInitializer" class="headerlink" title="2. ApplicationContextInitializer"></a>2. ApplicationContextInitializer</h1><p><validateCode>org.springframework.context.ApplicationContextInitializer</validateCode> ，ApplicationContext 初始化接口。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface for initializing a Spring {<span class="doctag">@link</span> ConfigurableApplicationContext}</span></span><br><span class="line"><span class="comment"> * prior to being {<span class="doctag">@linkplain</span> ConfigurableApplicationContext#refresh() refreshed}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Typically used within web applications that require some programmatic initialization</span></span><br><span class="line"><span class="comment"> * of the application context. For example, registering property sources or activating</span></span><br><span class="line"><span class="comment"> * profiles against the {<span class="doctag">@linkplain</span> ConfigurableApplicationContext#getEnvironment()</span></span><br><span class="line"><span class="comment"> * context's environment}. See {<span class="doctag">@validateCode</span> ContextLoader} and {<span class="doctag">@validateCode</span> FrameworkServlet} support</span></span><br><span class="line"><span class="comment"> * for declaring a "contextInitializerClasses" context-param and init-param, respectively.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;{<span class="doctag">@validateCode</span> ApplicationContextInitializer} processors are encouraged to detect</span></span><br><span class="line"><span class="comment"> * whether Spring's {<span class="doctag">@link</span> org.springframework.core.Ordered Ordered} interface has been</span></span><br><span class="line"><span class="comment"> * implemented or if the @{<span class="doctag">@link</span> org.springframework.core.annotation.Order Order}</span></span><br><span class="line"><span class="comment"> * annotation is present and to sort instances accordingly if so prior to invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;C&gt; the application context type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ContextLoader#customizeContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.context.ContextLoader#CONTEXT_INITIALIZER_CLASSES_PARAM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.FrameworkServlet#setContextInitializerClasses</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.servlet.FrameworkServlet#applyInitializers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">ConfigurableApplicationContext</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Initialize the given application context.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> applicationContext the application to configure</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">(C applicationContext)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>1、ApplicationContextInitializer 是 Spring Framework 3.1 版本开始提供的接口。而本文，我们是来分享 Spring Boot 中，几个 ApplicationContextInitializer 实现类。</li>
<li>2、【作用】ApplicationContextInitializer 是一个回调接口，用于 Spring ConfigurableApplicationContext 容器执行 <validateCode>#refresh()</validateCode> 方法进行初始化之前，提前走一些自定义的初始化逻辑。</li>
<li>3、【场景】它的使用场景，例如说 Web 应用中需要注册属性，或者激活 Profiles 。</li>
<li>4、【排序】它支持 Spring 的 Ordered 接口、<validateCode>@Order</validateCode> 注解，来对多个 ApplicationContextInitializer 实例进行排序，从而实现，ApplicationContextInitializer 按照顺序调用 <validateCode>#initialize(C applicationContext)</validateCode> 方法，进行初始化。</li>
</ul>
<h1 id="3-SpringApplication-中的使用"><a href="#3-SpringApplication-中的使用" class="headerlink" title="3. SpringApplication 中的使用"></a>3. SpringApplication 中的使用</h1><h2 id="3-1-初始化-ApplicationContextInitializer-集合"><a href="#3-1-初始化-ApplicationContextInitializer-集合" class="headerlink" title="3.1 初始化 ApplicationContextInitializer 集合"></a>3.1 初始化 ApplicationContextInitializer 集合</h2><p>在 SpringApplication 构造方法中，会调用 <validateCode>#getSpringFactoriesInstances(Class&lt;T&gt; type)</validateCode> 方法，获得 ApplicationContextInitializer 集合。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> getSpringFactoriesInstances(type, <span class="keyword">new</span> Class&lt;?&gt;[] {});</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">        Class&lt;?&gt;[] parameterTypes, Object... args)</span> </span>{</span><br><span class="line">    ClassLoader classLoader = getClassLoader();</span><br><span class="line">    <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">    <span class="comment">// &lt;1&gt; 加载指定类型对应的，在 `META-INF/spring.factories` 里的类名的数组</span></span><br><span class="line">    Set&lt;String&gt; names = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">    <span class="comment">// &lt;2&gt; 创建对象们</span></span><br><span class="line">    List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 排序对象们</span></span><br><span class="line">    AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">    <span class="keyword">return</span> instances;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，加载指定 ApplicationContextInitializer 类型对应的，在 <validateCode>META-INF/spring.factories</validateCode> 里的类名的数组。<ul>
<li>假设只在 Spring MVC 的环境下，<validateCode>initializers</validateCode> 属性的结果如下图：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-07/01.jpg" alt="`initializers` 属性"></li>
<li>艿艿整理了 Spring Boot 中，ApplicationContextInitializer 的实现类们，如下图所示：<img src="http://static2.iocoder.cn/images/Spring-Boot/2021-01-22/01.jpg" alt="Spring Boot ApplicationContextInitializer 的实现类"></li>
</ul>
</li>
<li><validateCode>&lt;2&gt;</validateCode> 处，创建对象们。</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，排序对象们。这个就是在 <a href="#">「2. ApplicationContextInitializer」</a> 提到的【排序】。</li>
</ul>
<h2 id="3-2-prepareContext"><a href="#3-2-prepareContext" class="headerlink" title="3.2 prepareContext"></a>3.2 prepareContext</h2><p>在 <validateCode>#prepareContext(...)</validateCode> 方法中，即在 Spring IoC 容器初始化之前，会调用 <validateCode>#applyInitializers()</validateCode> 方法，逐个调用 ApplicationContextInitializer 的初始化方法。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// SpringApplication.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// 遍历 ApplicationContextInitializer 数组</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer initializer : getInitializers()) {</span><br><span class="line">        <span class="comment">// 校验 ApplicationContextInitializer 的泛型非空</span></span><br><span class="line">        Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(), ApplicationContextInitializer.class);</span><br><span class="line">        Assert.isInstanceOf(requiredType, context, <span class="string">"Unable to call initializer."</span>);</span><br><span class="line">        <span class="comment">// 初始化 ApplicationContextInitializer</span></span><br><span class="line">        initializer.initialize(context);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>比较简单，就是调用 <validateCode>ApplicationContextInitializer#initialize(context)</validateCode> 方法，进行初始化。</li>
</ul>
<p>下面，我们来逐个看看 Spring Boot 对 ApplicationContextInitializer 的实现类们。</p>
<h1 id="4-DelegatingApplicationContextInitializer"><a href="#4-DelegatingApplicationContextInitializer" class="headerlink" title="4. DelegatingApplicationContextInitializer"></a>4. DelegatingApplicationContextInitializer</h1><p><validateCode>org.springframework.boot.context.config.DelegatingApplicationContextInitializer</validateCode> ，实现 ApplicationContextInitializer、Ordered 接口，根据环境变量配置的 <validateCode>context.initializer.classes</validateCode> 配置的 ApplicationContextInitializer 类们，交给它们进行初始化。</p>
<h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1 构造方法"></a>4.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// DelegatingApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环境变量配置的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROPERTY_NAME = <span class="string">"context.initializer.classes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 构造方法为空</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>优先级为 0 ，在 Spring Boot 默认的 ApplicationContextInitializer 实现类中，是排在最前面的。</li>
</ul>
<h2 id="4-2-initialize"><a href="#4-2-initialize" class="headerlink" title="4.2 initialize"></a>4.2 initialize</h2><p>实现 <validateCode>#initialize(ConfigurableApplicationContext context)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// DelegatingApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得环境变量配置的 ApplicationContextInitializer 集合们</span></span><br><span class="line">    ConfigurableEnvironment environment = context.getEnvironment();</span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; initializerClasses = getInitializerClasses(environment);</span><br><span class="line">    <span class="comment">// 如果非空，则进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!initializerClasses.isEmpty()) {</span><br><span class="line">        applyInitializerClasses(context, initializerClasses);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#getInitializerClasses(ConfigurableEnvironment env)</validateCode> 方法，获得环境变量配置的 ApplicationContextInitializer 集合们。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// DelegatingApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Class&lt;?&gt;&gt; getInitializerClasses(ConfigurableEnvironment env) {</span><br><span class="line">    <span class="comment">// 获得环境变量配置的属性</span></span><br><span class="line">    String classNames = env.getProperty(PROPERTY_NAME);</span><br><span class="line">    <span class="comment">// 拼装成数组，按照 ，分隔</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(classNames)) {</span><br><span class="line">        <span class="keyword">for</span> (String className : StringUtils.tokenizeToStringArray(classNames, <span class="string">","</span>)) {</span><br><span class="line">            classes.add(getInitializerClass(className));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getInitializerClass(String className) <span class="keyword">throws</span> LinkageError {</span><br><span class="line">	<span class="keyword">try</span> {</span><br><span class="line">		<span class="comment">// 获得全类名，对应的类</span></span><br><span class="line">		Class&lt;?&gt; initializerClass = ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());</span><br><span class="line">		Assert.isAssignable(ApplicationContextInitializer.class, initializerClass);</span><br><span class="line">		<span class="keyword">return</span> initializerClass;</span><br><span class="line">	} <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"Failed to load context initializer class ["</span> + className + <span class="string">"]"</span>, ex);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#applyInitializerClasses(ConfigurableApplicationContext context, List&lt;Class&lt;?&gt;&gt; initializerClasses)</validateCode> 方法，执行初始化。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// DelegatingApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyInitializerClasses</span><span class="params">(ConfigurableApplicationContext context, List&lt;Class&lt;?&gt;&gt; initializerClasses)</span> </span>{</span><br><span class="line">    Class&lt;?&gt; contextClass = context.getClass();</span><br><span class="line">    <span class="comment">// 遍历 initializerClasses 数组，创建对应的 ApplicationContextInitializer 对象们 ①</span></span><br><span class="line">    List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; initializerClass : initializerClasses) {</span><br><span class="line">        initializers.add(instantiateInitializer(contextClass, initializerClass));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 执行 ApplicationContextInitializer 们的初始化逻辑 ②</span></span><br><span class="line">    applyInitializers(context, initializers);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 ① 处调用</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContextInitializer&lt;?&gt; instantiateInitializer(Class&lt;?&gt; contextClass, Class&lt;?&gt; initializerClass) {</span><br><span class="line">    <span class="comment">// 断言校验</span></span><br><span class="line">    Class&lt;?&gt; requireContextClass = GenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.class);</span><br><span class="line">    Assert.isAssignable(requireContextClass, contextClass, String.format(</span><br><span class="line">                    <span class="string">"Could not add context initializer [%s]"</span></span><br><span class="line">                            + <span class="string">" as its generic parameter [%s] is not assignable "</span></span><br><span class="line">                            + <span class="string">"from the type of application context used by this "</span></span><br><span class="line">                            + <span class="string">"context loader [%s]: "</span>,</span><br><span class="line">                    initializerClass.getName(), requireContextClass.getName(), contextClass.getName()));</span><br><span class="line">    <span class="comment">// 创建 ApplicationContextInitializer 对象</span></span><br><span class="line">    <span class="keyword">return</span> (ApplicationContextInitializer&lt;?&gt;) BeanUtils.instantiateClass(initializerClass);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被 ② 处调用</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>({ <span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span> })</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyInitializers</span><span class="params">(ConfigurableApplicationContext context, List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers)</span> </span>{</span><br><span class="line">    <span class="comment">// 排序，无处不在的排序！</span></span><br><span class="line">    initializers.sort(<span class="keyword">new</span> AnnotationAwareOrderComparator());</span><br><span class="line">    <span class="comment">// 执行初始化逻辑</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer initializer : initializers) {</span><br><span class="line">        initializer.initialize(context);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然代码有点长，但是简单的。</li>
</ul>
</li>
</ul>
<h1 id="5-SharedMetadataReaderFactoryContextInitializer"><a href="#5-SharedMetadataReaderFactoryContextInitializer" class="headerlink" title="5. SharedMetadataReaderFactoryContextInitializer"></a>5. SharedMetadataReaderFactoryContextInitializer</h1><p><validateCode>org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer</validateCode> ，实现 ApplicationContextInitializer、Ordered 接口，它会创建一个用于在 ConfigurationClassPostProcessor 和 Spring Boot 间共享的 CachingMetadataReaderFactory Bean 对象。</p>
<p>简化代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ApplicationContextInitializer} to create a shared</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> CachingMetadataReaderFactory} between the</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ConfigurationClassPostProcessor} and Spring Boot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Phillip Webb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建的 CachingMetadataReaderFactory 的 Bean 名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEAN_NAME = <span class="string">"org.springframework.boot.autoconfigure."</span></span><br><span class="line">        + <span class="string">"internalCachingMetadataReaderFactory"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>{</span><br><span class="line">    applicationContext.addBeanFactoryPostProcessor(<span class="keyword">new</span> CachingMetadataReaderFactoryPostProcessor());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略 CachingMetadataReaderFactoryPostProcessor 内部类</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>看不懂这个类的具体用途，暂时先不去深究。😈 等真的需要它时，咱们在细细的撸它。</li>
</ul>
<h1 id="6-ContextIdApplicationContextInitializer"><a href="#6-ContextIdApplicationContextInitializer" class="headerlink" title="6. ContextIdApplicationContextInitializer"></a>6. ContextIdApplicationContextInitializer</h1><p><validateCode>org.springframework.boot.context.ContextIdApplicationContextInitializer</validateCode> ，实现 ApplicationContextInitializer、Ordered 接口，负责生成 Spring 容器的编号。</p>
<h2 id="6-1-构造方法"><a href="#6-1-构造方法" class="headerlink" title="6.1 构造方法"></a>6.1 构造方法</h2><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ContextIdApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> order = Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-2-initialize"><a href="#6-2-initialize" class="headerlink" title="6.2 initialize"></a>6.2 initialize</h2><p>实现 <validateCode>#initialize(ConfigurableApplicationContext context)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ContextIdApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得（创建） ContextId 对象</span></span><br><span class="line">    ContextId contextId = getContextId(applicationContext);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 设置到 applicationContext 中</span></span><br><span class="line">    applicationContext.setId(contextId.getId());</span><br><span class="line">    <span class="comment">// &lt;3&gt; 注册到 contextId 到 Spring 容器中</span></span><br><span class="line">    applicationContext.getBeanFactory().registerSingleton(ContextId.class.getName(), contextId);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p>ContextId ，是 ContextIdApplicationContextInitializer 的内部类，Spring 容器编号的封装。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ContextIdApplicationContextInitializer#ContextId.java</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextId</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicLong children = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">	ContextId(String id) {</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建子 Context 的编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="function">ContextId <span class="title">createChildId</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ContextId(<span class="keyword">this</span>.id + <span class="string">"-"</span> + <span class="keyword">this</span>.children.incrementAndGet());</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">String <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#getContextId(ConfigurableApplicationContext applicationContext)</validateCode> 方法，获得（创建） ContextId 对象。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ContextIdApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ContextId <span class="title">getContextId</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得父 ApplicationContext 对象</span></span><br><span class="line">    ApplicationContext parent = applicationContext.getParent();</span><br><span class="line">    <span class="comment">// 情况一，如果父 ApplicationContext 存在，且有对应的 ContextId 对象，则使用它生成当前容器的 ContextId 对象</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span> &amp;&amp; parent.containsBean(ContextId.class.getName())) {</span><br><span class="line">        <span class="keyword">return</span> parent.getBean(ContextId.class).createChildId();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 情况二，创建 ContextId 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ContextId(getApplicationId(applicationContext.getEnvironment()));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getApplicationId</span><span class="params">(ConfigurableEnvironment environment)</span> </span>{</span><br><span class="line">    String name = environment.getProperty(<span class="string">"spring.application.name"</span>);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.hasText(name) ? name : <span class="string">"application"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一般情况下，使用 <validateCode>"spring.application.name"</validateCode> 环境变量，作为 ContextId 对象的 <validateCode>id</validateCode> 属性。</li>
</ul>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，设置到 <validateCode>applicationContext.id</validateCode> 中。</p>
</li>
<li><validateCode>&lt;3&gt;</validateCode> 处，注册到 <validateCode>contextId</validateCode> 到 Spring 容器中。这样，后续就可以拿到了。</li>
</ul>
<h1 id="7-ConfigurationWarningsApplicationContextInitializer"><a href="#7-ConfigurationWarningsApplicationContextInitializer" class="headerlink" title="7. ConfigurationWarningsApplicationContextInitializer"></a>7. ConfigurationWarningsApplicationContextInitializer</h1><blockquote>
<p>艿艿：对于这个类，选择性了解即可。</p>
</blockquote>
<p><validateCode>org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer</validateCode> ，实现 ApplicationContextInitializer 接口，用于检查配置，报告错误的配置。如下是其类上的注释：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * {<span class="doctag">@link</span> ApplicationContextInitializer} to report warnings for common misconfiguration mistakes.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-1-initialize"><a href="#7-1-initialize" class="headerlink" title="7.1 initialize"></a>7.1 initialize</h2><p>实现 <validateCode>#initialize(ConfigurableApplicationContext applicationContext)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> </span>{</span><br><span class="line">	<span class="comment">// 注册 ConfigurationWarningsPostProcessor 到 Spring 容器中</span></span><br><span class="line">	context.addBeanFactoryPostProcessor(<span class="keyword">new</span> ConfigurationWarningsPostProcessor(getChecks()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>注册 ConfigurationWarningsPostProcessor 到 Spring 容器中。关于 ConfigurationWarningsPostProcessor 类，在 <a href="#">「7.2 ConfigurationWarningsPostProcessor」</a> 中，详细解析。</li>
<li><p>其中，<validateCode>#getChecks()</validateCode> 方法，返回 Check 数组。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Check[] getChecks() {</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Check[] { <span class="keyword">new</span> ComponentScanPackageCheck() };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>返回的数组，只有一个 ComponentScanPackageCheck 对象。</li>
</ul>
</li>
<li>Check ，是 ConfigurationWarningsApplicationContextInitializer 的内部接口，校验器。代码如下：  <figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">interface</span> <span class="title">Check</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns a warning if the check fails or {<span class="doctag">@validateCode</span> null} if there are no problems.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> registry the {<span class="doctag">@link</span> BeanDefinitionRegistry}</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> a warning message or {<span class="doctag">@validateCode</span> null}</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">String <span class="title">getWarning</span><span class="params">(BeanDefinitionRegistry registry)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ul>
<li>看到此处，胖友可能有点懵逼，不着急。在 <a href="#">「7.2 ConfigurationWarningsPostProcessor」</a> 中，会串起来滴。</li>
</ul>
<h2 id="7-2-ConfigurationWarningsPostProcessor"><a href="#7-2-ConfigurationWarningsPostProcessor" class="headerlink" title="7.2 ConfigurationWarningsPostProcessor"></a>7.2 ConfigurationWarningsPostProcessor</h2><p>ConfigurationWarningsPostProcessor ，是 ConfigurationWarningsApplicationContextInitializer 的内部静态类，实现 PriorityOrdered、BeanDefinitionRegistryPostProcessor 接口，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsPostProcessor#ConfigurationWarningsPostProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationWarningsPostProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">PriorityOrdered</span>, <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Check[] checks;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigurationWarningsPostProcessor</span><span class="params">(Check[] checks)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.checks = checks;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Ordered.LOWEST_PRECEDENCE - <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>{}</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>{</span><br><span class="line">        <span class="comment">// 遍历 Check 数组，执行校验。若有错，则打印 warn 日志</span></span><br><span class="line">        <span class="keyword">for</span> (Check check : <span class="keyword">this</span>.checks) {</span><br><span class="line">            String message = check.getWarning(registry);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(message)) {</span><br><span class="line">                warn(message);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String message)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) {</span><br><span class="line">            logger.warn(String.format(<span class="string">"%n%n** WARNING ** : %s%n%n"</span>, message));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>核心就是 <validateCode>#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</validateCode> 方法。在其内部，遍历 Check 数组，执行校验。若有错，则打印 warn 日志。在上文中，我们看到目前 <validateCode>checks</validateCode> 只有一个 ComponentScanPackageCheck 元素。关于它，我们在 <a href="#">「7.3 ComponentScanPackageCheck」</a> 详细解析。</li>
</ul>
<h2 id="7-3-ComponentScanPackageCheck"><a href="#7-3-ComponentScanPackageCheck" class="headerlink" title="7.3 ComponentScanPackageCheck"></a>7.3 ComponentScanPackageCheck</h2><p>ComponentScanPackageCheck ，实现 Check 接口，检查是否使用了 <validateCode>@ComponentScan</validateCode> 注解，扫描了指定扫描的包。</p>
<h3 id="7-3-1-构造方法"><a href="#7-3-1-构造方法" class="headerlink" title="7.3.1 构造方法"></a>7.3.1 构造方法</h3><figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsPostProcessor#ComponentScanPackageCheck.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有问题的包的集合。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即禁止使用 <span class="doctag">@ComponentScan</span> 注解扫描这个集合中的包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; PROBLEM_PACKAGES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> {</span><br><span class="line">    Set&lt;String&gt; packages = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    packages.add(<span class="string">"org.springframework"</span>);</span><br><span class="line">    packages.add(<span class="string">"org"</span>);</span><br><span class="line">    PROBLEM_PACKAGES = Collections.unmodifiableSet(packages);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>即禁止扫描 <validateCode>"org.springframework"</validateCode> 和 <validateCode>"org"</validateCode> 包。因为 <validateCode>"org.springframework"</validateCode> 包下，有非常多的 Bean ，这样扫描，会错误的注入很多 Bean 。</li>
</ul>
<h3 id="7-3-2-getWarning"><a href="#7-3-2-getWarning" class="headerlink" title="7.3.2 getWarning"></a>7.3.2 getWarning</h3><p>实现 <validateCode>#getWarning(BeanDefinitionRegistry registry)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsPostProcessor#ComponentScanPackageCheck.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getWarning</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得要扫描的包</span></span><br><span class="line">    Set&lt;String&gt; scannedPackages = getComponentScanningPackages(registry);</span><br><span class="line">    <span class="comment">// &lt;2&gt; 获得要扫描的包中，有问题的包</span></span><br><span class="line">    List&lt;String&gt; problematicPackages = getProblematicPackages(scannedPackages);</span><br><span class="line">    <span class="comment">// &lt;3.1&gt; 如果 problematicPackages 为空，说明不存在问题</span></span><br><span class="line">    <span class="keyword">if</span> (problematicPackages.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// &lt;3.2&gt; 如果 problematicPackages 非空，说明有问题，返回错误提示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Your ApplicationContext is unlikely to "</span></span><br><span class="line">            + <span class="string">"start due to a @ComponentScan of "</span></span><br><span class="line">            + StringUtils.collectionToDelimitedString(problematicPackages, <span class="string">", "</span>)</span><br><span class="line">            + <span class="string">"."</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，调用 <validateCode>#getComponentScanningPackages(BeanDefinitionRegistry registry)</validateCode> 方法，获得要扫描的包。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsPostProcessor#ComponentScanPackageCheck.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;String&gt; <span class="title">getComponentScanningPackages</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    <span class="comment">// 扫描的包的集合</span></span><br><span class="line">    Set&lt;String&gt; packages = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获得所有 BeanDefinition 的名字们</span></span><br><span class="line">    String[] names = registry.getBeanDefinitionNames();</span><br><span class="line">    <span class="keyword">for</span> (String name : names) {</span><br><span class="line">        <span class="comment">// 如果是 AnnotatedBeanDefinition</span></span><br><span class="line">        BeanDefinition definition = registry.getBeanDefinition(name);</span><br><span class="line">        <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) {</span><br><span class="line">            AnnotatedBeanDefinition annotatedDefinition = (AnnotatedBeanDefinition) definition;</span><br><span class="line">            <span class="comment">// 如果有 @ComponentScan 注解，则添加到 packages 中</span></span><br><span class="line">            addComponentScanningPackages(packages, annotatedDefinition.getMetadata());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> packages;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addComponentScanningPackages</span><span class="params">(Set&lt;String&gt; packages, AnnotationMetadata metadata)</span> </span>{</span><br><span class="line">    <span class="comment">// 获得 @ComponentScan 注解</span></span><br><span class="line">    AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(ComponentScan.class.getName(), <span class="keyword">true</span>));</span><br><span class="line">    <span class="comment">// 如果存在，则添加到 packages 中</span></span><br><span class="line">    <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) {</span><br><span class="line">        addPackages(packages, attributes.getStringArray(<span class="string">"value"</span>));</span><br><span class="line">        addPackages(packages, attributes.getStringArray(<span class="string">"basePackages"</span>));</span><br><span class="line">        addClasses(packages, attributes.getStringArray(<span class="string">"basePackageClasses"</span>));</span><br><span class="line">        <span class="keyword">if</span> (packages.isEmpty()) {</span><br><span class="line">            packages.add(ClassUtils.getPackageName(metadata.getClassName()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPackages</span><span class="params">(Set&lt;String&gt; packages, String[] values)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) {</span><br><span class="line">        Collections.addAll(packages, values);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addClasses</span><span class="params">(Set&lt;String&gt; packages, String[] values)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (String value : values) {</span><br><span class="line">            packages.add(ClassUtils.getPackageName(value));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>虽然很长，但是比较简单。就是找 <validateCode>@ComponentScan</validateCode> 注解所扫描的包。</li>
</ul>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#getProblematicPackages(Set&lt;String&gt; scannedPackages)</validateCode> 方法，获得要扫描的包中，有问题的包。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ConfigurationWarningsPostProcessor#ComponentScanPackageCheck.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getProblematicPackages</span><span class="params">(Set&lt;String&gt; scannedPackages)</span> </span>{</span><br><span class="line">    <span class="comment">// 有问题的包的集合</span></span><br><span class="line">    List&lt;String&gt; problematicPackages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String scannedPackage : scannedPackages) {</span><br><span class="line">        <span class="comment">// 判断是否在 PROBLEM_PACKAGES 中。如果是，则添加到 problematicPackages 中</span></span><br><span class="line">        <span class="keyword">if</span> (isProblematicPackage(scannedPackage)) {</span><br><span class="line">            problematicPackages.add(getDisplayName(scannedPackage));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> problematicPackages;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isProblematicPackage</span><span class="params">(String scannedPackage)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (scannedPackage == <span class="keyword">null</span> || scannedPackage.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> PROBLEM_PACKAGES.contains(scannedPackage);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getDisplayName</span><span class="params">(String scannedPackage)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (scannedPackage == <span class="keyword">null</span> || scannedPackage.isEmpty()) {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"the default package"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"'"</span> + scannedPackage + <span class="string">"'"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>😈 就是判断 <validateCode>scannedPackages</validateCode> 哪些在 <validateCode>PROBLEM_PACKAGES</validateCode> 中。</li>
</ul>
</li>
<li><p><validateCode>&lt;3.1&gt;</validateCode> 处，如果 <validateCode>problematicPackages</validateCode> 为空，说明不存在问题。</p>
</li>
<li><validateCode>&lt;3.2&gt;</validateCode> 处，如果 <validateCode>problematicPackages</validateCode> 非空，说明有问题，返回错误提示。</li>
</ul>
<h1 id="8-ServerPortInfoApplicationContextInitializer"><a href="#8-ServerPortInfoApplicationContextInitializer" class="headerlink" title="8. ServerPortInfoApplicationContextInitializer"></a>8. ServerPortInfoApplicationContextInitializer</h1><p><validateCode>org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</validateCode> ，实现 ApplicationContextInitializer、ApplicationListener 接口，监听 EmbeddedServletContainerInitializedEvent 类型的事件，然后将内嵌的 Web 服务器使用的端口给设置到 ApplicationContext 中。</p>
<h2 id="8-1-initialize"><a href="#8-1-initialize" class="headerlink" title="8.1 initialize"></a>8.1 initialize</h2><p>实现 <validateCode>#initialize(ConfigurableApplicationContext applicationContext)</validateCode> 方法，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServerPortInfoApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>{</span><br><span class="line">	applicationContext.addApplicationListener(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>将自身作为一个 ApplicationListener 监听器，添加到 Spring 容器中。</li>
</ul>
<h2 id="8-2-onApplicationEvent"><a href="#8-2-onApplicationEvent" class="headerlink" title="8.2 onApplicationEvent"></a>8.2 onApplicationEvent</h2><p>实现 <validateCode>#onApplicationEvent(WebServerInitializedEvent event)</validateCode> 方法，当监听到 WebServerInitializedEvent 事件，进行触发。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServerPortInfoApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>{</span><br><span class="line">    <span class="comment">// &lt;1&gt; 获得属性名</span></span><br><span class="line">    String propertyName = <span class="string">"local."</span> + getName(event.getApplicationContext()) + <span class="string">".port"</span>;</span><br><span class="line">    <span class="comment">// &lt;2&gt; 设置端口到 environment 的 propertyName 中</span></span><br><span class="line">    setPortProperty(event.getApplicationContext(), propertyName, event.getWebServer().getPort());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><validateCode>&lt;1&gt;</validateCode> 处，获得属性名。其中，<validateCode>#getName(WebServerApplicationContext context)</validateCode> 方法，获得 WebServer 的名字。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServerPortInfoApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">(WebServerApplicationContext context)</span> </span>{</span><br><span class="line">	String name = context.getServerNamespace();</span><br><span class="line">	<span class="keyword">return</span> StringUtils.hasText(name) ? name : <span class="string">"server"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><validateCode>&lt;2&gt;</validateCode> 处，调用 <validateCode>#setPortProperty(ApplicationContext context, String propertyName, int port)</validateCode> 方法，设置端口到 <validateCode>environment</validateCode> 的 <validateCode>propertyName</validateCode> 中。代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="validateCode"><pre><span class="line"><span class="comment">// ServerPortInfoApplicationContextInitializer.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPortProperty</span><span class="params">(ApplicationContext context, String propertyName, <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">    <span class="comment">// 设置端口到 environment 的 propertyName 中</span></span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ConfigurableApplicationContext) {</span><br><span class="line">        setPortProperty(((ConfigurableApplicationContext) context).getEnvironment(), propertyName, port);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果有父容器，则继续设置</span></span><br><span class="line">    <span class="keyword">if</span> (context.getParent() != <span class="keyword">null</span>) {</span><br><span class="line">        setPortProperty(context.getParent(), propertyName, port);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPortProperty</span><span class="params">(ConfigurableEnvironment environment, String propertyName, <span class="keyword">int</span> port)</span> </span>{</span><br><span class="line">    MutablePropertySources sources = environment.getPropertySources();</span><br><span class="line">    <span class="comment">// 获得 "server.ports" 属性对应的值</span></span><br><span class="line">    PropertySource&lt;?&gt; source = sources.get(<span class="string">"server.ports"</span>);</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) {</span><br><span class="line">        source = <span class="keyword">new</span> MapPropertySource(<span class="string">"server.ports"</span>, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        sources.addFirst(source);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 添加到 source 中</span></span><br><span class="line">    ((Map&lt;String, Object&gt;) source.getSource()).put(propertyName, port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>注意噢，设置的属性结果是，<validateCode>"server.ports"</validateCode> 中，的 KEY 为 <validateCode>propertyName</validateCode> ，VALUE 为 <validateCode>port</validateCode> 。😈</li>
</ul>
</li>
</ul>
<h1 id="9-其他-ApplicationContextInitializer-实现类"><a href="#9-其他-ApplicationContextInitializer-实现类" class="headerlink" title="9. 其他 ApplicationContextInitializer 实现类"></a>9. 其他 ApplicationContextInitializer 实现类</h1><p>ApplicationContextInitializer 还有一些其它实现类，不是很重要，可以选择不看。</p>
<ul>
<li><validateCode>spring-boot-test</validateCode> 模块<ul>
<li><validateCode>org.springframework.boot.test.context.ConfigFileApplicationContextInitializer</validateCode> 类</li>
<li><validateCode>org.springframework.boot.test.context.SpringBootContextLoader</validateCode> 中的 ParentContextApplicationContextInitializer 类</li>
</ul>
</li>
<li><validateCode>spring-boot-devtools</validateCode> 模块<ul>
<li><validateCode>org.springframework.boot.devtools.restart.RestartScopeInitializer</validateCode> 类</li>
</ul>
</li>
<li><validateCode>spring-boot-autoconfigure</validateCode> 模块<ul>
<li><validateCode>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</validateCode> 类</li>
</ul>
</li>
<li><validateCode>spring-boot</validateCode> 模块<ul>
<li><validateCode>org.springframework.boot.web.servlet.support.ServletContextApplicationContextInitializer</validateCode> 类</li>
<li><validateCode>org.springframework.boot.builder.ParentContextApplicationContextInitializer</validateCode> 类</li>
</ul>
</li>
</ul>
<p>😈 貌似还是蛮多的。</p>
<h1 id="666-彩蛋"><a href="#666-彩蛋" class="headerlink" title="666. 彩蛋"></a>666. 彩蛋</h1><p>小更一下，算是水文~感觉比较有收获的 ApplicationContextInitializer 的实现类是：</p>
<ul>
<li><a href="#">「6. ContextIdApplicationContextInitializer」</a></li>
<li><a href="#">「8. ServerPortInfoApplicationContextInitializer」</a></li>
</ul>
<p>参考和推荐如下文章：</p>
<ul>
<li>dm_vincent <a href="https://blog.csdn.net/dm_vincent/article/details/77619780" rel="external nofollow noopener noreferrer" target="_blank">《[Spring Boot] 5. Spring Boot 中的ApplicationContext - 执行 ApplicationContextInitializer 初始化器》</a></li>
</ul>




</div>